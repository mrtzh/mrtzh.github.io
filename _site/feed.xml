<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Moody Rd</title>
    <description>A blog about machine learning.</description>
    <link>http://blog.mrtz.org/</link>
    <atom:link href="http://blog.mrtz.org/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 27 Aug 2016 08:19:39 -0700</pubDate>
    <lastBuildDate>Sat, 27 Aug 2016 08:19:39 -0700</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>Understanding fairness in machine learning</title>
        <description>&lt;p&gt;As machine learning increasingly affects domains protected by anti-discrimination law, there is much interest in the problem of algorithmically measuring and ensuring fairness in machine learning. Across academia and industry, machine learning experts are finally embracing this important research direction that has long been marred by sensationalist clickbait overshadowing scientific efforts.&lt;/p&gt;

&lt;p&gt;This sequence of posts is a sober take on the subtleties and difficulties in engaging productively with the issue of fairness in machine learning. Prudence is necessary, since a poor regulatory proposal could easily do more harm than doing nothing at all.&lt;/p&gt;

&lt;p&gt;In this first post, I will focus on a sticky idea I call &lt;em&gt;demographic parity&lt;/em&gt; that through its many variants has been proposed as a fairness criterion in dozens of papers. I will argue that demographic parity not only cripples the utility of machine learning, it also fails to guarantee fairness.&lt;/p&gt;

&lt;p&gt;In a second post, I will introduce you to a measure of fairness put forward in a recent joint work with &lt;a href=&quot;http://www.cs.utexas.edu/~ecprice/&quot;&gt;Price&lt;/a&gt; and &lt;a href=&quot;http://ttic.uchicago.edu/~nati/&quot;&gt;Srebro&lt;/a&gt; that addresses the main conceptual shortcomings of demographic parity, while being easy enough to apply and to interpret. A third post will use our framework to unravel the recent controversy on COMPAS scores. Finally, I’ll devote an entire post on limitations of our work, and avenues for future research.&lt;/p&gt;

&lt;h2 id=&quot;a-call-to-action&quot;&gt;A call to action&lt;/h2&gt;

&lt;p&gt;Domains such as advertising, credit, education, and employment can all hugely benefit from modern machine learning techniques, but some are concerned that algorithms might introduce new biases or perpetuate existing ones. Indeed, the Obama Administration’s Big Data Working Group &lt;a href=&quot;https://www.whitehouse.gov/sites/default/files/docs/big_data_privacy_report_may_1_2014.pdf&quot;&gt;argued in 2014&lt;/a&gt; that discrimination may &quot;be the inadvertent outcome of the way big
data technologies are structured and used&quot; and pointed toward &quot;the potential
of encoding discrimination in automated decisions&quot;.&lt;/p&gt;

&lt;p&gt;It’s important to understand on technical grounds how decisions based on machine learning might &lt;a href=&quot;https://medium.com/@mrtz/how-big-data-is-unfair-9aa544d739de#.llzo69u3p&quot;&gt;wind up being unfair without any explicit wrongdoing&lt;/a&gt;. Some will be disappointed to find that the core issues have little to do with Silicon Valley billionaires or the singularity, and more to do with fundamental conceptual and technical challenges.&lt;/p&gt;

&lt;p&gt;But it’s also important to understand that often the use of algorithms exposes biases present in society rather than creating new ones. There is an exciting opportunity of eliminating biases as we move to an algorithmic ecosystem.&lt;/p&gt;

&lt;p&gt;Despite the need and the opportunity, a vetted methodology for ensuring fairness in machine learning is lacking. Historically, the uninformed approach to fairness has been to say that the algorithm simply doesn’t look at &lt;em&gt;protected attributes&lt;/em&gt; such as race, color, religion, gender, disability, or family status. So, how could it discriminate? This idea of &lt;em&gt;fairness through ignorance&lt;/em&gt;, however, fails due to the existence of &lt;em&gt;redundant encodings&lt;/em&gt;, ways of predicting protected attributes from other features. After all, this is what machine learning is good at. It’s very likely that a representation rich enough to predict, say, future crimes of an individual would also in one way or the other encode race.&lt;/p&gt;

&lt;h2 id=&quot;demographic-parity&quot;&gt;Demographic parity&lt;/h2&gt;

&lt;p&gt;After ruling out &lt;em&gt;fairness through ignorance&lt;/em&gt;, the next idea that comes to mind is &lt;em&gt;demographic parity&lt;/em&gt;. Demographic parity requires that a decision—such as accepting or denying a loan application—be independent of the protected attribute. In the case of a binary decision &lt;script type=&quot;math/tex&quot;&gt;C\in\{0,1\}&lt;/script&gt; and a binary protected attribute &lt;script type=&quot;math/tex&quot;&gt;A\in\{0,1\},&lt;/script&gt; this constraint can be formalized by asking that&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathbb{P}\{C=1 \mid A=0\}=\mathbb{P}\{C=1 \mid A=1\}.&lt;/script&gt;

&lt;p&gt;In other words, membership in a protected class should have no correlation with the decision. Through its various equivalent formalizations and other variants this idea appears in numerous papers. For example, in the context of representation learning, it is tempting to ask that the 
learned representation has zero &lt;a href=&quot;https://en.wikipedia.org/wiki/Mutual_information&quot;&gt;mutual information&lt;/a&gt; with the protected attribute. Any classifier based on the learned representation will then inevitably satisfy demographic parity.&lt;/p&gt;

&lt;p&gt;Unfortunately, as my colleagues and I &lt;a href=&quot;https://arxiv.org/abs/1104.3913&quot;&gt;argued&lt;/a&gt; long ago, the
notion is seriously flawed on two counts.&lt;/p&gt;

&lt;h3 id=&quot;demographic-parity-doesnt-ensure-fairness&quot;&gt;Demographic parity doesn’t ensure fairness.&lt;/h3&gt;

&lt;p&gt;Indeed, the notion permits that we accept qualified applicants in the demographic A=0, but unqualified individuals in A=1, so long as the percentages of acceptance match. Consider, for example, a lender that accepts proportionally fewer qualified black applicants, but makes up for it by accepting more unqualified black applicants. This situation should strike you as unfair, but demographic parity is completely fine with it so long as the bias against qualified black applicants cancels the bias in favor of unqualified black applicants.&lt;/p&gt;

&lt;p&gt;You might argue that it’s never in the lender’s interest to reject qualified applicants. This is a good point that we’ll return to shortly. However, the above scenario can arise naturally, when there is little or no training data available about a minority population as I illustrated in a &lt;a href=&quot;https://medium.com/@mrtz/how-big-data-is-unfair-9aa544d739de#.llzo69u3p&quot;&gt;previous post&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;demographic-parity-cripples-the-utility-of-machine-learning&quot;&gt;Demographic parity cripples the utility of machine learning.&lt;/h3&gt;

&lt;p&gt;Imagine we could actually see into the future, or, equivalently we had a perfect predictor of future events. Formally, this predictor C would always equal the target variable Y. In the context of loans, this predictor would tell us precisely who will actually default and who doesn’t. We assume for a moment that such a perfect predictor exists. Using C to make loan decision can then hardly be considered discriminatory as it represents the actual outcome. Unfortunately, for loans (and many other problems) the variable Y is (anti-)correlated with the protected group A. As a consequence, demographic parity would rule out the ideal predictor C = Y. So, even if we could see into the future and know who exactly will default on a loan or not, we still couldn’t make that our classification outcome. As a result, the loss in utility of imposing demographic parity can be substantial for &lt;em&gt;no good reason&lt;/em&gt;. Demographic parity is simply misaligned with the fundamental goal of achieving higher prediction accuracy.&lt;/p&gt;

&lt;p&gt;To be sure, there is a set of applications for which demographic parity is not unreasonable, but this is often a subtle case to make. Any paper adopting demographic parity without making a compelling case for it should strike you as dubious.&lt;/p&gt;

&lt;h3 id=&quot;simpsons-paradox&quot;&gt;Simpson’s paradox&lt;/h3&gt;

&lt;p&gt;I shall note in passing that demographic parity is also quite sensitive to &lt;a href=&quot;https://en.wikipedia.org/wiki/Simpson%27s_paradox&quot;&gt;Simpson’s paradox&lt;/a&gt;. A classic paper by Bickel et al. studying gender bias in college admissions showed how violations to demographic parity can disappear (or even reverse in sign) when data is binned differently. Roughly speaking, what seemed to be a bias against women at the university-wide admissions level, reversed to be a slight bias against men when stratified by department. According to Pearl, the actual paradox about Simpson’s paradox is that there is no easy resolution. Depending on causal relations, sometimes aggregate data is preferable for decision-making compared with further subdivision, but sometimes it is not.&lt;/p&gt;

&lt;h3 id=&quot;moving-forward&quot;&gt;Moving forward&lt;/h3&gt;

&lt;p&gt;As I argued, demographic parity is both too strong and too weak. Hence, if you find a different condition that’s strictly stronger, it’ll still be flawed. If you come up with something strictly weaker, it’ll still be flawed. You also won’t salvage demographic parity by finding more impressive ways of achieving it such as backpropping through a 1200 layer neural net with spatial attention and unconscious sigmund activations.&lt;/p&gt;

&lt;p&gt;If demographic parity is simply broken, why did I belabor its failure at such great length? One reason is simply to discourage people from writing more and more papers about it without a compelling explanation of why it makes sense for their application. The more important reason, however, is that the failure of demographic parity is actually quite an instructive lesson to learn. In particular, we will see how it suggests a much more reasonable notion that I will introduce in my next post.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Stay on top of future posts. Subscribe to the &lt;a href=&quot;http://blog.mrtz.org/feed.xml&quot;&gt;RSS feed&lt;/a&gt;, or follow me on &lt;a href=&quot;https://twitter.com/mrtz&quot;&gt;Twitter&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 20 Jul 2016 10:00:00 -0700</pubDate>
        <link>http://blog.mrtz.org/2016/07/20/demographic-parity.html</link>
        <guid isPermaLink="true">http://blog.mrtz.org/2016/07/20/demographic-parity.html</guid>
        
        <category>fairness</category>
        
        <category>machine learning</category>
        
        <category>statistics</category>
        
        
      </item>
    
      <item>
        <title>Stability as a foundation of machine learning</title>
        <description>&lt;p&gt;&lt;em&gt;Cross-posted at &lt;a href=&quot;http://www.offconvex.org/2016/03/14/stability/&quot;&gt;offconvex.org&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Central to machine learning is our ability to relate how a learning algorithm fares on a sample to its performance on unseen instances. This is called &lt;em&gt;generalization&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In this post, I will describe a purely algorithmic approach to generalization. The property that makes this possible is &lt;em&gt;stability&lt;/em&gt;. An algorithm is &lt;em&gt;stable&lt;/em&gt;, intuitively speaking, if its output doesn’t change much if we perturb the input sample in a single point. We will see that this property by itself is necessary and sufficient for generalization.&lt;/p&gt;

&lt;h2 id=&quot;example-stability-of-the-perceptron-algorithm&quot;&gt;Example: Stability of the Perceptron algorithm&lt;/h2&gt;

&lt;p&gt;Before we jump into the formal details, let’s consider a simple example of a stable algorithm: The &lt;a href=&quot;https://en.wikipedia.org/wiki/Perceptron&quot;&gt;Perceptron&lt;/a&gt;, aka stochastic gradient descent for learning linear separators! The algorithm aims to separate two classes of points (here circles and triangles) with a linear separator. The algorithm starts with an arbitrary hyperplane. It then repeatedly selects a single example from its input set and updates its hyperplane using the gradient of a certain loss function on the chosen example. How bad might the algorithm screw up if we move around a single example? Let’s find out.&lt;/p&gt;

&lt;p&gt;&lt;!-- begin animation --&gt;&lt;/p&gt;
&lt;div style=&quot;text-align:center;&quot;&gt;
   &lt;img id=&quot;imganim&quot; src=&quot;/assets/sgd/00.png&quot; onclick=&quot;forward_image()&quot; /&gt;
   &lt;p style=&quot;text-align:center;&quot;&gt;&lt;em&gt;Step &lt;span style=&quot;font-family:monospace;&quot;&gt;&lt;span id=&quot;counter&quot;&gt;1&lt;/span&gt;/30&lt;/span&gt;. Click to advance.&lt;br /&gt; The animation shows two runs of the Perceptron algorithm for learning a linear separator on two data sets that differ in the one point marked green in one data set and purple in the other. The perturbation is indicated by an arrow. The shaded green region shows the difference in the resulting two hyperplanes after some number of steps. &lt;/em&gt;&lt;/p&gt;
  &lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;//&lt;![CDATA[
  var images = [
  &quot;/assets/sgd/00.png&quot;,
  &quot;/assets/sgd/01.png&quot;,
  &quot;/assets/sgd/02.png&quot;,
  &quot;/assets/sgd/03.png&quot;,
  &quot;/assets/sgd/04.png&quot;,
  &quot;/assets/sgd/05.png&quot;,
  &quot;/assets/sgd/06.png&quot;,
  &quot;/assets/sgd/07.png&quot;,
  &quot;/assets/sgd/08.png&quot;,
  &quot;/assets/sgd/09.png&quot;,
  &quot;/assets/sgd/10.png&quot;,
  &quot;/assets/sgd/11.png&quot;,
  &quot;/assets/sgd/12.png&quot;,
  &quot;/assets/sgd/13.png&quot;,
  &quot;/assets/sgd/14.png&quot;,
  &quot;/assets/sgd/15.png&quot;,
  &quot;/assets/sgd/16.png&quot;,
  &quot;/assets/sgd/17.png&quot;,
  &quot;/assets/sgd/18.png&quot;,
  &quot;/assets/sgd/19.png&quot;,
  &quot;/assets/sgd/20.png&quot;, 
  &quot;/assets/sgd/21.png&quot;,
  &quot;/assets/sgd/22.png&quot;,
  &quot;/assets/sgd/23.png&quot;,
  &quot;/assets/sgd/24.png&quot;,
  &quot;/assets/sgd/25.png&quot;,
  &quot;/assets/sgd/26.png&quot;,
  &quot;/assets/sgd/27.png&quot;,
  &quot;/assets/sgd/28.png&quot;,
  &quot;/assets/sgd/29.png&quot; ]
  var i = 0
  function forward_image(){
   i = i + 1;
   document.getElementById('imganim').src = images[i%30];
   document.getElementById('counter').textContent = (i%30) + 1;
  }
  //]]&gt; 
  &lt;/script&gt;

&lt;p&gt;&lt;!-- end animation --&gt;&lt;/p&gt;

&lt;p&gt;As we can see by clicking impatiently through the example, the algorithm seems pretty stable. Even if we substantially move the first example it encounters, the hyperplane computed by the algorithm changes only slightly. Neat. (You can check out the code &lt;a href=&quot;https://gist.github.com/mrtzh/266c37d3a274376134a6&quot;&gt;here&lt;/a&gt;.)&lt;/p&gt;

&lt;h2 id=&quot;empirical-risk-jargon&quot;&gt;Empirical risk jargon&lt;/h2&gt;

&lt;p&gt;Let’s introduce some terminology to relate the behavior of an algorithm on a sample to its behavior on unseen instances. Imagine we have a sample $S=(z_1,\dots,z_n)$ drawn i.i.d. from some unknown distribution $D$. There’s a learning algorithm $A(S)$ that takes $S$ and produces some model (e.g., the hyperplane in the above picture). To quantify the quality of the model we crank out a &lt;em&gt;loss function&lt;/em&gt; $\ell$ with the idea that $\ell(A(S), z)$ describes the &lt;em&gt;loss&lt;/em&gt; of the model $A(S)$ on one instance $z$. The &lt;em&gt;empirical risk&lt;/em&gt; or &lt;em&gt;training error&lt;/em&gt; of the algorithm is defined as:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;R_S = \frac1n \sum_{i=1}^n \ell(A(S), z_i)&lt;/script&gt;

&lt;p&gt;This captures the average loss of the algorithm on the sample on which it was trained. To quantify &lt;em&gt;out-of-sample&lt;/em&gt; performance, we define the &lt;em&gt;risk&lt;/em&gt; of the algorithm as:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;R = \mathop{\mathbb{E}}_{z\sim D}\left[ \ell(A(S), z) \right]&lt;/script&gt;

&lt;p&gt;The difference between risk and empirical risk $R - R_S$ is called &lt;em&gt;generalization error&lt;/em&gt;. You will sometimes encounter that term as a synonym for risk, but I find that confusing. We already have a perfectly short and good name for the risk $R$. Always keep in mind the following tautology&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;R = R_S + (R-R_S).&lt;/script&gt;

&lt;p&gt;Operationally, it states that if we manage to minimize empirical risk all that matters is generalization error.&lt;/p&gt;

&lt;h2 id=&quot;a-fundamental-theorem-of-machine-learning&quot;&gt;A fundamental theorem of machine learning&lt;/h2&gt;

&lt;p&gt;I probably shouldn’t propose fundamental theorems for anything really. But if I had to, this would be the one I’d suggest for machine learning:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;In expectation, generalization equals stability.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Somewhat more formally, we will encounter a natural measure of stability, denoted $\Delta$ such that the difference between risk and empirical risk in expectation equals $\Delta.$ Formally,&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathbb{E}[R - R_S] = \Delta&lt;/script&gt;

&lt;p&gt;Deferring the exact definition of $\Delta$ to the proof, let’s think about this for a second.
What I find so remarkable about this theorem is that it turns a statistical problem into a purely algorithmic one: All we need for generalization is an algorithmic notion of robustness. Our algorithm’s output shouldn’t change much if perturb one of the data points. It’s almost like a sanity check. Had you coded up an algorithm and this wasn’t the case, you’d probably go look for a bug.&lt;/p&gt;

&lt;h3 id=&quot;proof&quot;&gt;Proof&lt;/h3&gt;

&lt;p&gt;Consider two data sets of size $n$ drawn independently of each other:
[
S = (z_1,\dots,z_n), \qquad S’=(z_1’,\dots,z_n’)
]
The idea of taking such a &lt;em&gt;ghost sample&lt;/em&gt; $S’$ is quite old and already arises in the context of &lt;em&gt;symmetrization&lt;/em&gt; in empirical process theory.
We’re going to couple these two samples in one point by defining
[
S^i = (z_1,\dots,z_{i-1},z_i’,z_{i+1},\dots,z_n),\qquad i = 1,\dots, n.
]
It’s certainly no coincidence that $S$ and $S^i$ differ in exactly one element. We’re going to use this in just a moment.&lt;/p&gt;

&lt;p&gt;By definition, the &lt;em&gt;expected empirical risk&lt;/em&gt; equals&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathbb{E}[R_S] = \mathbb{E}\left[ \frac1n \sum_{i=1}^n \ell(A(S), z_i) \right].&lt;/script&gt;

&lt;p&gt;Contrasting this to how the algorithm fares on unseen examples, we can rewrite the &lt;em&gt;expected risk&lt;/em&gt; using our ghost sample as:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathbb{E}[R] = \mathbb{E}\left[ \frac1n \sum_{i=1}^n \ell(A(S), \color{red}{z_i'}) \right]&lt;/script&gt;

&lt;p&gt;All expectations we encounter are over both $S$ and $S’$. By linearity of expectation, the difference between expected risk and expected empirical risk equals&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathbb{E}[R - R_S] 
= \frac1n \sum_{i=1}^n 
\mathbb{E}\left[\ell(A(S), \color{red}{z_i'})-\ell(A(S), z_i)\right].&lt;/script&gt;

&lt;p&gt;It is tempting now to relate the two terms inside the expectation to the stability of the algorithm. We’re going to do exactly that using mathematics’ most trusted proof strategy: &lt;em&gt;pattern matching&lt;/em&gt;. Indeed, since $z_i$ and $z_i’$ are exchangeable, we have&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathbb{E}[\ell(A(S), z_i)] 
= \mathbb{E}[\ell(A(S^i), z_i')]
= \mathbb{E}[\ell(A(S), z_i')] - \delta_i,&lt;/script&gt;

&lt;p&gt;where $\delta_i$ is defined to make the second equality true:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\delta_i = \mathbb{E}[\ell(A(\color{red}S), z_i')- \ell(A(\color{red}{S^i}), z_i')]&lt;/script&gt;

&lt;p&gt;Summing up $\Delta = (1/n)\sum_i \delta_i$, we have&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathbb{E}[ R - R_S ] = \Delta.&lt;/script&gt;

&lt;p&gt;The only thing left to do is to interpret the right hand side in terms of stability. Convince yourself that $\delta_i$ measures how differently the algorithm behaves on two data sets $S$ and $S’$ that differ in only one element.&lt;/p&gt;

&lt;h3 id=&quot;uniform-stability&quot;&gt;Uniform stability&lt;/h3&gt;

&lt;p&gt;It can be difficult to analyze the expectation in the definition of $\Delta$ precisely. Fortunately, it is often enough to resolve the expectation by upper bounding it with suprema:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;|\Delta| \le \sup_{S,S'} \sup_{z} \left|\ell(A(S),z)-\ell(A(S'),z)\right|.&lt;/script&gt;

&lt;p&gt;The supremum runs over all valid data sets differing in only one element and all valid sample points $z$. This stronger notion of stability called &lt;em&gt;uniform stability&lt;/em&gt; 
goes back to a seminal paper by Bousquett and Elisseeff.&lt;/p&gt;

&lt;p&gt;I should say that you can find the above proof in the essssential stability paper by Shalev-Shwartz, Shamir, Srebro and Sridharan &lt;a href=&quot;http://jmlr.csail.mit.edu/papers/volume11/shalev-shwartz10a/shalev-shwartz10a.pdf&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;concentration-from-stability&quot;&gt;Concentration from stability&lt;/h3&gt;

&lt;p&gt;The theorem we saw shows that &lt;em&gt;expected&lt;/em&gt; empirical risk equals risk up to a correction that involves the stability of the algorithm. Can we also show that empirical risk is close to its expectation with high probability? Interestingly, we can by appealing to stability once again. I won’t spell out the details, but we can use the &lt;a href=&quot;https://en.wikipedia.org/wiki/Doob_martingale#McDiarmid.27s_inequality&quot;&gt;method of bounded differences&lt;/a&gt; to obtain strong concentration bounds. To apply the method we need a &lt;em&gt;bounded difference&lt;/em&gt; condition which is just another word for &lt;em&gt;stability&lt;/em&gt;. So, we’re really killing two birds with one stone by using stability not only to show that the first moment of the empirical risk is correct but also that it concentrates. The only wrinkle is that, as far as I know, the weak stability notion expressed by $\Delta$ is not enough to get concentration, but uniform stability (for sufficiently small difference) will do.&lt;/p&gt;

&lt;h2 id=&quot;applications-of-stability&quot;&gt;Applications of stability&lt;/h2&gt;

&lt;p&gt;There is much more that stability can do for us. We’ve only scratched on the surface. Here are some of the many applications of stability.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.jmlr.org/papers/volume2/bousquet02a/bousquet02a.pdf&quot;&gt;Regularization implies stability&lt;/a&gt;. Specifically, the minimizer of the empirical risk subject to an $\ell_2$-penalty is uniformly stable.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://arxiv.org/abs/1509.01240&quot;&gt;Stochastic gradient descent is stable&lt;/a&gt; provided that we don’t make too many steps.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Differential privacy is nothing but a strong stability guarantee. Any result ever proved about differential privacy is fundamentally about stability.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Differential privacy in turn has applications to preventing overfitting in &lt;a href=&quot;http://blog.mrtz.org/2015/12/14/adaptive-data-analysis.html&quot;&gt;adaptive data analysis&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Stability also has many beautiful applications and connections in statistics. I strongly encourage you to read Bin Yu’s beautiful &lt;a href=&quot;https://www.stat.berkeley.edu/~binyu/ps/papers2013/Yu13.pdf&quot;&gt;overview paper&lt;/a&gt; on the topic.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Looking ahead, I’ve got at least two more posts planned on this.&lt;/p&gt;

&lt;p&gt;In my next post I will go into the stability of stochastic gradient descent in detail. We will see a simple argument to show that stochastic gradient descent is uniformly stable. I will then work towards applying these ideas to the area of deep learning. We will see that stability can help us explain why even huge models sometimes generalize well and how we can make them generalize even better.&lt;/p&gt;

&lt;p&gt;In a second post I will reflect on stability as a paradigm for reliable machine learning. The focus will be on how ideas from stability can help avoid overfitting and false discovery.&lt;/p&gt;
</description>
        <pubDate>Mon, 14 Mar 2016 01:00:00 -0700</pubDate>
        <link>http://blog.mrtz.org/2016/03/14/stability.html</link>
        <guid isPermaLink="true">http://blog.mrtz.org/2016/03/14/stability.html</guid>
        
        <category>machine learning</category>
        
        
      </item>
    
      <item>
        <title>Adaptive Data Analysis</title>
        <description>&lt;p&gt;I just returned from &lt;a href=&quot;https://nips.cc/Conferences/2015/&quot;&gt;NIPS 2015&lt;/a&gt;, a joyful week 
of corporate parties featuring deep learning themed cocktails, &lt;a href=&quot;http://www.nytimes.com/2015/12/12/science/artificial-intelligence-research-center-is-founded-by-silicon-valley-investors.html?_r=0&quot;&gt;money
talk&lt;/a&gt;,
recruiting events, and some scientific activities on the side. In the latter
category, I co-organized a &lt;a href=&quot;http://wadapt.org&quot;&gt;workshop on adaptive data
analysis&lt;/a&gt; with Vitaly Feldman, Aaron Roth and Adam Smith.&lt;/p&gt;

&lt;p&gt;Our workshop responds to an increasingly pressing issue in machine learning and
statistics. The classic view of these fields has it that we choose our method
independently of the data to which we intend to apply the method. For example,
a hypothesis test must be fixed in advance before we see the data. I sometimes
call this &lt;em&gt;static&lt;/em&gt; or &lt;em&gt;confirmatory&lt;/em&gt; data analysis. You need to know exactly
what you want to do before you collect the data and run your experiment. In
contrast, in practice we typically choose our methods as a function of the data
to which we apply them. In other words, we &lt;em&gt;adapt&lt;/em&gt; our method to the data.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/static-adaptive.jpg&quot; alt=&quot;static vs adaptive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Adaptivity is both powerful and dangerous. Working adaptively gives us greater
flexibility to make unanticipated discoveries as it allows us to execute more
complex analysis work flows. But it can also lead to false discovery and
misleading conclusions far more easily than static data analysis. While there
are many other issues to keep in mind,  is not unreasonable to blame our lack
of understanding adaptivity in part for exacerbating a range of problems from
&lt;a href=&quot;http://www.stat.columbia.edu/~gelman/research/unpublished/p_hacking.pdf&quot;&gt;false discovery in the empirical
sciences&lt;/a&gt;
to &lt;a href=&quot;http://blog.mrtz.org/2015/03/09/competition.html&quot;&gt;overfitting in machine learning
competitions&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I was hugely impressed with the incredibly exciting group of participants and
audiences from both computer science and statistics that our workshop brought
together. I felt that we made actual progress on beginning to understand the
diverse perspectives on this complex issue. The goal of this post is to convey
my excitement for this emerging research area as I attempt to summarize the
different perspectives we saw.&lt;/p&gt;

&lt;h2 id=&quot;the-frequentist-statistics-perspective&quot;&gt;The frequentist statistics perspective&lt;/h2&gt;

&lt;p&gt;Null hypothesis tests are still widely used across the empirical sciences to
gauge the validity of findings. Scientists routinely calculate
&lt;a href=&quot;https://en.wikipedia.org/wiki/P-value&quot;&gt;p-values&lt;/a&gt; with the hope of being able
to reject a null hypothesis and thus claim a “statistically significant”
finding. If we carry out multiple hypothesis tests, we need to adjust our
p-values for the fact that we made multiple tests. A safe way of correcting for
multiple tests is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bonferroni_correction&quot;&gt;Bonferroni
correction&lt;/a&gt; which amounts
to multiplying all p-values by the number of tests. Computer scientists call this
the union bound. While Bonferroni is safe, it makes discoveries difficult in
the common situation where we have lots of tests and no individual signal is
particularly strong. A more
&lt;a href=&quot;https://en.wikipedia.org/wiki/Statistical_power&quot;&gt;powerful&lt;/a&gt; alternative to
Bonferroni is to control the &lt;a href=&quot;https://en.wikipedia.org/wiki/False_discovery_rate&quot;&gt;False Discovery
Rate&lt;/a&gt; (FDR) proposed in a
celebrated paper by Benjamini and Hochberg. Intuitively, controlling FDR
amounts to putting a bound on the expected ratio of all false discoveries
(number of rejected true null hypotheses) to all discoveries (number of
rejected nulls). The famous Benjamini-Hochberg procedure gives one beautiful
way of doing this.&lt;/p&gt;

&lt;h3 id=&quot;online-false-discovery-rate&quot;&gt;Online False Discovery Rate&lt;/h3&gt;

&lt;p&gt;Andrea Montanari and Dean Foster discussed more recent works on &lt;a href=&quot;http://arxiv.org/abs/1502.06197&quot;&gt;online
variants of FDR&lt;/a&gt;. Here, the goal is to control
FDR not at the end of the testing process, but rather at all points along the
way. In particular, the scientist must choose whether or not to reject a
hypothesis at any time point without knowing the outcome of future tests. The
word &lt;em&gt;online&lt;/em&gt; should not be confused with &lt;em&gt;adaptive&lt;/em&gt;. Although we could in
principle choose hypotheses adaptively in this framework, we still need the
traditional assumptions that all p-values are independent of each other and
distributed the way they should be (i.e., uniform if the null hypothesis is
true). If the selection of hypothesis tests was truly adaptive, these
assumptions are unlikely to be satisfied and hard to be verified at any rate.&lt;/p&gt;

&lt;h3 id=&quot;inference-after-selection&quot;&gt;Inference after selection&lt;/h3&gt;

&lt;p&gt;But what if our hypothesis tests are chosen as a function of the data? For
example, what if we first choose a set of promising data attributes and test
only these attributes for significance? This natural two-step procedure is
called &lt;em&gt;inference after selection&lt;/em&gt; in statistics. Rob Tibshirani gave an entire
keynote about this topic. Will Fithian went into further detail in his talk at
our workshop. Several recent works in this area show how we can first perform
variable selection using an algorithm such as
&lt;a href=&quot;http://statweb.stanford.edu/~tibs/lasso.html&quot;&gt;Lasso&lt;/a&gt;, followed by hypothesis
testing on the selected variables. What makes these results possible is a
careful analysis of the distribution of the p-values conditional on the
selection by Lasso. For example, if the test statistic followed a normal
distribution before selection, it will follow a certain truncated normal
distribution after selection. This approach leads to very accurate
characterizations and often tight confidence intervals. However, it has the
shortcoming that the we need to commit to a particular selection and inference
procedure as the analysis crucially exploits these.&lt;/p&gt;

&lt;p&gt;Rina Foygel Barber expanded on the theme of adaptivity and false discovery rate
by showing how to control FDR when we first &lt;a href=&quot;http://arxiv.org/abs/1505.07352&quot;&gt;order our hypothesis
tests&lt;/a&gt; in a data-dependent manner to allow for
making important discoveries sooner.&lt;/p&gt;

&lt;h2 id=&quot;the-bayesian-view&quot;&gt;The Bayesian view&lt;/h2&gt;

&lt;p&gt;Andrew Gelman’s talk (see &lt;a href=&quot;http://wadapt.org/slides/gelman.pdf&quot;&gt;his slides&lt;/a&gt;)
contributed many illustrative examples of flawed empirical studies. His
suggested cure for the woes of adaptivity was to do &lt;em&gt;more&lt;/em&gt; of it. However, he
advocated &lt;a href=&quot;https://en.wikipedia.org/wiki/Bayesian_hierarchical_modeling&quot;&gt;Bayesian hierarchical
modeling&lt;/a&gt; to
explicitly account for all the possible outcomes of an adaptive study. When
asked if this wouldn’t put too much burden on the side of modeling, he replied
that modeling should be seen as a feature as it forces people to explicitly
discuss the experimental setup.&lt;/p&gt;

&lt;h2 id=&quot;the-stability-approach&quot;&gt;The stability approach&lt;/h2&gt;

&lt;p&gt;An intriguing approach to generalization in machine learning is the idea of
&lt;em&gt;stability&lt;/em&gt;. An algorithm is &lt;em&gt;stable&lt;/em&gt; if its output changes only slightly (in
some formal sense) under an arbitrary substitution of a single input data
point. A seminal work of Bousquet and Elisseeff showed that &lt;a href=&quot;http://www.jmlr.org/papers/volume2/bousquet02a/bousquet02a.pdf&quot;&gt;stability implies
generalization&lt;/a&gt;.
That is, patterns observed by a &lt;em&gt;stable&lt;/em&gt; algorithm on a sample must also exist
in the underlying population from which the sample was drawn. Nati Srebro
explained in his talk how stability is a universal property in the sense that
it is both &lt;a href=&quot;http://jmlr.csail.mit.edu/papers/volume11/shalev-shwartz10a/shalev-shwartz10a.pdf&quot;&gt;sufficient and necessary for
learnability&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/stability.png&quot; alt=&quot;stability&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The issue is that stability by itself doesn’t address adaptivity. Indeed, the
classic works on stability apply to the typical &lt;em&gt;non-adaptive&lt;/em&gt; setting of
learning where the sample is independent of the learning algorithm.&lt;/p&gt;

&lt;p&gt;Cynthia Dwork talked about recent works that address this shortcoming.
Specifically, differential privacy is a stability notion that applies even in
the setting of adaptive data analysis. Hence, &lt;a href=&quot;http://arxiv.org/abs/1411.2664&quot;&gt;differential privacy implies
validity in adaptive data analysis&lt;/a&gt;. Drawing on
many powerful adaptive data analysis algorithms from differential privacy, this
gives a range of statistically valid tools for adaptive data analysis. See, for
example, my blog post on the &lt;a href=&quot;http://googleresearch.blogspot.com/2015/08/the-reusable-holdout-preserving.html&quot;&gt;reusable holdout
method&lt;/a&gt;
that came out of this line of work.&lt;/p&gt;

&lt;h2 id=&quot;information-theoretic-measures&quot;&gt;Information-theoretic measures&lt;/h2&gt;

&lt;p&gt;The intuition behind differential privacy is that if an analysis does not
reveal too much about the specifics of a data set, then it is impossible to
overfit to the data set based on the available information. This suggests an
information-theoretic approach that quantifies the &lt;em&gt;mutual information&lt;/em&gt; between
the sample and the output of the algorithm. A &lt;a href=&quot;http://arxiv.org/abs/1506.02629&quot;&gt;recent
work&lt;/a&gt; shows that indeed certain strengthenings
of mutual information prevent overfitting. Being completely general, this
viewpoint allows us, for example, to discuss deterministic algorithms, whereas
all differentially private algorithms are randomized. James Zou discussed the
information-theoretic approach further and mentioned his &lt;a href=&quot;http://arxiv.org/abs/1511.05219&quot;&gt;recent
work&lt;/a&gt; on this topic.&lt;/p&gt;

&lt;h2 id=&quot;complexity-theoretic-obstructions&quot;&gt;Complexity-theoretic obstructions&lt;/h2&gt;

&lt;p&gt;In a dramatic turn of events, Jon Ullman told us why &lt;a href=&quot;http://arxiv.org/abs/1408.1655&quot;&gt;preventing false
discovery in adaptive data analysis can be computationally
intractable&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To understand the result, think of adaptive data analysis for a moment as an
interactive protocol between the data analyst and the algorithm. The algorithm
has access to a sample of size \(n\) and the analyst wants to learn about the
underlying population by asking the algorithm a sequence of adaptively chosen
questions.&lt;/p&gt;

&lt;p&gt;What Jon talked about is that there is a computationally efficient adaptive
data analyst that can force any computationally efficient algorithm on a sample
of size \(n\) to return a completely invalid estimate after no more than
\(n^2\) adaptively chosen questions. Non-adaptively, this would require
exponentially many questions. While this is a worst-case hardness result, it
points to a computational barrier for what might have looked like a purely
statistical problem. The \(n^2\) bound turns out to be tight in light of the
differential privacy based positive results I mentioned earlier.&lt;/p&gt;

&lt;h2 id=&quot;panel-discussion&quot;&gt;Panel discussion&lt;/h2&gt;

&lt;p&gt;Toward the end of our workshop, we had a fantastic panel discussion on open
problems and conceptual questions. I don’t remember all of it, unfortunately.
Below are some topics that got stuck in my mind. If you remember more, please
leave a comment.&lt;/p&gt;

&lt;h3 id=&quot;exact-modeling-versus-worst-case-assumptions&quot;&gt;Exact modeling versus worst-case assumptions&lt;/h3&gt;

&lt;p&gt;The approaches we saw cluster around two extremes. One is the case of exact
analysis or modeling, for example, in the work on inference after selection. In
these cases, we are able to exactly analyze the conditional distributions
arising as a result of adaptivity and adjust our methods accordingly. The work
on differential privacy in contrast makes no assumptions on the analyst. Both
approaches have advantages and disadvantages. One is more exact and
quantitatively less wasteful, but applies only to specific procedures. The
other is more general and less restrictive to the analyst, but this generality
also leads to hardness results. A goal for future work is to find middle
ground.&lt;/p&gt;

&lt;h3 id=&quot;human-adaptivity-versus-algorithmic-adaptivity&quot;&gt;Human adaptivity versus algorithmic adaptivity&lt;/h3&gt;

&lt;p&gt;There is a curious distinction we need to draw. Algorithms can be adaptive.
&lt;a href=&quot;http://blog.mrtz.org/2013/09/07/the-zen-of-gradient-descent.html&quot;&gt;Gradient
descent&lt;/a&gt;, for
example, is adaptive because it probes the data at a sequence of adaptively
chosen points. Lasso followed by inference is another example of a single
algorithm that exhibits some adaptive behavior. However, adaptivity also arises
through the way humans work adaptively with the data. It even arises when a
group of researchers study the same data set through a sequence of
publications. Each publication builds on previous insights and is hence
adaptive. It is much harder to analyze human adaptivity than algorithmic
adaptivity. How can we even quantify the extent to which this is a problem?
Take &lt;a href=&quot;http://yann.lecun.com/exdb/mnist/&quot;&gt;MNIST&lt;/a&gt;, for example. For almost two
decades this data set has been used as a benchmark with the &lt;em&gt;same&lt;/em&gt; test set.
Although no individual algorithm is directly trained against the test set, it
is quite likely that the sequence of proposed algorithms over the years
strongly overfits to the test data. It seems that this is an issue we should
take more seriously.&lt;/p&gt;

&lt;h3 id=&quot;building-better-intuition-in-practice&quot;&gt;Building better intuition in practice&lt;/h3&gt;

&lt;p&gt;Any practical application of the algorithms we discussed will likely violate
either the modeling assumptions we make or the quantitative regime to which our
theory applies. This shouldn’t be surprising. Even in non-adaptive data
analysis we make assumptions (such as normal approximations) that are not
completely true in practice. What is different is that we have far less
intuition for what works in practice in the adaptive setting.&lt;/p&gt;

&lt;h3 id=&quot;whats-next&quot;&gt;What’s next?&lt;/h3&gt;

&lt;p&gt;After this workshop, I’m even more convinced that adaptive data analysis
is here to stay. I expect lots of work in this area with many new theoretical
insights. I also hope that these developments will lead to new tools that make
the practice of machine learning and statistics more reliable.&lt;/p&gt;

</description>
        <pubDate>Sun, 13 Dec 2015 18:00:00 -0800</pubDate>
        <link>http://blog.mrtz.org/2015/12/13/adaptive-data-analysis.html</link>
        <guid isPermaLink="true">http://blog.mrtz.org/2015/12/13/adaptive-data-analysis.html</guid>
        
        <category>tcs</category>
        
        <category>statistics</category>
        
        
      </item>
    
      <item>
        <title>Navigate the garden of the forking paths</title>
        <description>&lt;p&gt;Head on over to the Google Research blog for bleeding edge coverage of 
&lt;a href=&quot;http://googleresearch.blogspot.com/2015/08/the-reusable-holdout-preserving.html&quot;&gt;The reusable holdout: Preserving validity in adaptive data
analysis&lt;/a&gt;, a joint work with Cynthia Dwork, Vitaly Feldman, Toni Pitassi,
Aaron Roth and Omer Reingold, to appear in &lt;em&gt;Science&lt;/em&gt;, tomorrow.&lt;/p&gt;
</description>
        <pubDate>Thu, 06 Aug 2015 13:55:00 -0700</pubDate>
        <link>http://blog.mrtz.org/2015/08/06/reusable.html</link>
        <guid isPermaLink="true">http://blog.mrtz.org/2015/08/06/reusable.html</guid>
        
        <category>tcs</category>
        
        <category>statistics</category>
        
        <category>false discovery</category>
        
        <category>data</category>
        
        <category>privacy</category>
        
        
      </item>
    
      <item>
        <title>Towards practicing differential privacy</title>
        <description>&lt;p&gt;More than a year ago I wrote an article with the provocative title: &lt;a href=&quot;http://blog.mrtz.org/2013/08/21/dp-practical.html&quot;&gt;Is
Differential Privacy practical?&lt;/a&gt;
The post was essentially one big buildup for
an epic follow-up post that I simply never wrote. Since then dozens
have asked me for an answer to this urgent question. Recently, after the post
hit the front page of Hacker News, half a dozen emails
inquired about the follow-up post that I had promised. Some &lt;a href=&quot;https://news.ycombinator.com/item?id=9184479&quot;&gt;speculated&lt;/a&gt; that owing to &lt;a href=&quot;http://en.wikipedia.org/wiki/Betteridge%27s_law_of_headlines&quot;&gt;Betteridge’s law of
headlines&lt;/a&gt;, the
answer was simply &lt;em&gt;no&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Despite my venerable history of failing on various commitments and my apparent
peace with it, this situation went too far even by my own low standards.
So, I decided to write a not so epic version of that promised blog
post.&lt;/p&gt;

&lt;h2 id=&quot;the-california-public-utilities-commission&quot;&gt;The California Public Utilities Commission&lt;/h2&gt;

&lt;p&gt;I’ll arrange my thoughts around the case of the &lt;a href=&quot;http://www.cpuc.ca.gov/puc/&quot;&gt;California Public
Utilities Commission&lt;/a&gt; (CPUC). The CPUC is a
regulatory agency that regulates privately owned public utilities in
California. In recent years there has been political pressure on the utilities
to give third parties access to smart meter data. As discussed in &lt;a href=&quot;http://blog.mrtz.org/2013/08/21/dp-practical.html&quot;&gt;my previous
post&lt;/a&gt;, smart meter data is
of enormous value to many, but comes with serious privacy challenges.&lt;/p&gt;

&lt;p&gt;To settle these issues the CPUC organized a major legal proceeding with the
goal of creating rules that provide access to energy usage data to local
government entities, researchers, and state and federal agencies while
establishing procedures that protect the privacy of consumer data.&lt;/p&gt;

&lt;p&gt;I served as a privacy expert within the proceeding together with Cynthia Dwork, Lee Tien from the
&lt;a href=&quot;http://www.eff.org&quot;&gt;EFF&lt;/a&gt;, and Jennifer Urban and her team from Berkeley.
Our goal was to inform various parties about the pitfalls
of insufficient privacy mechanisms and to propose better ones. Our proposed
solution focused on differential privacy for the uses cases in which it made
sense. There were a number of use cases that the CPUC considered. Not all of
them were well suited for differential privacy to begin with.&lt;/p&gt;

&lt;h3 id=&quot;a-proposed-decision&quot;&gt;A proposed decision&lt;/h3&gt;

&lt;p&gt;My involvement with the case ended in 2014 after a &lt;a href=&quot;http://docs.cpuc.ca.gov/PublishedDocs/Efile/G000/M088/K947/88947979.PDF&quot;&gt;proposed
decision&lt;/a&gt;
of the administrative judge. To summarize a 120 page document in one sentence,
the ruling did not endorse differential privacy strongly enough for me to further pursue the case actively.
Nevertheless, there was still significant interest in differential privacy
from some of the utilities. I believe that one utilities company
engaged with Microsoft with the goal of building a prototype of a
differentially private solution for their data sharing needs.&lt;/p&gt;

&lt;p&gt;The ruling was disappointing from my perspective in that it did not advocate
the use of differential privacy in any of the use cases. Meanwhile it shot
down several uses cases essentially not giving the use
case sponsors meaningful access to energy data at all. In those cases
differential privacy could’ve provided an obviously better trade-off for everyone.&lt;/p&gt;

&lt;p&gt;The ruling didn’t so much reflect a technical verdict about differential privacy. Rather it reflected our inability to successfully anticipate and maneuver the highly complex political and legal environment in which the decision was made.&lt;/p&gt;

&lt;h3 id=&quot;a-post-mortem&quot;&gt;A post mortem&lt;/h3&gt;

&lt;p&gt;Our proposal based on differential privacy initially met with resoundingly positive
responses when we first presented it to the administrative judge and various
parties present in the meeting. We did however face bitter opposition from a
group of researchers who sponsored one use case. Those researchers, who had
been working with raw smart meter data in the past, were worried that differential privacy
would create an obstacle for them. We quickly realized that it would be
difficult to agree with them on the extent to which their research practices
are compatible with differential privacy. So, we specifically excluded their
use case from the scope of our proposal focusing on some of the remaining use cases instead. This
didn’t stop the researchers from lobbying relentlessly against differential
privacy. In particular, they filed a last minute comment in which they
attacked differential privacy sharply based on many profound factual misunderstandings
of the privacy notion. Due to the perfect timing of their comment, we were
unable to submit a rebuttal. In the end, I believe this alone was enough for the
administrative judge to conclude that the use of differential privacy was at
present too controversial to be proposed as a solution in the ruling.&lt;/p&gt;

&lt;p&gt;My point is not to criticize this group of researchers. I’m sympathetic with
them. They’ve been working with energy data for many years. They’re doing important work which is probably already difficult enough as it is. We respected their
position and did not want to interfere with their research. My guess
is that their research practices are actually largely consistent with what’s
possible under differential privacy, but that’s an entirely separate
discussion.&lt;/p&gt;

&lt;p&gt;What’s tragic is that their opposition ended up hurting a consumer advocacy
group who could’ve used differential privacy as a means to gain &lt;em&gt;more&lt;/em&gt; access to
energy data than they were able to get in the end (essentially nothing). There was a lot of miscommunication throughout the proceeding that clearly didn’t help. For instance, initially the consumer advocacy group proposed their own ad-hoc privacy solution (which we didn’t support). Only later did we find some common ground. In hindsight, we should’ve agreed on and jointly represented the same solution from the beginning. In my understanding, the use case didn’t require more than the kind of aggregate usage statistics that we could’ve easily produced while preserving differential privacy without any major engineering efforts.&lt;/p&gt;

&lt;h2 id=&quot;towards-practicing-differential-privacy&quot;&gt;Towards practicing differential privacy&lt;/h2&gt;

&lt;p&gt;Drawing on my experience with the CPUC case, I want to end with some concrete
suggestions and questions hoping that they will help others when applying
differential privacy. When I speak of “the community”, I will make some very broad generalizations knowing full well that in each instance there are certainly exceptions to what I claim. The discussion below is by no means a survey as it contains very few links to the rich literature on differential privacy. I strongly encourage you to fill in relevant missing pointers in the comments.&lt;/p&gt;

&lt;h3 id=&quot;focus-on-win-win-applications&quot;&gt;Focus on win-win applications&lt;/h3&gt;

&lt;p&gt;Apply differential privacy as a tool to provide access to data where
currently access is problematic due to privacy regulations. Don’t fight the
data analyst. Don’t play the moral police. Imagine you are the analyst.&lt;/p&gt;

&lt;p&gt;As a privacy expert,
you will find yourself having to shoot down inadequate solutions all the time.
Why can’t we just omit those 18 sensitive attributes like in the HIPAA safe harbor provision?
Why isn’t it safe to release any statistic that is aggregated over at least 15 households in which no
single household contributes 15% of the total number (i.e., the “15/15” rule)?
Such ad-hoc rules sound intuitively appealing to non-experts. Refuting them is time-consuming and makes
you look defensive.&lt;/p&gt;

&lt;p&gt;Rather than shooting down what doesn’t work, point out why differential privacy is better than those solutions not just from a privacy perspective but rather from a &lt;em&gt;utility&lt;/em&gt; perspective. Unlike these solutions,
differential privacy does not alter your data set at all. In particular, from a statistical perspective
you do not change the distribution from which the data were drawn. This is an incredibly powerful
proposition. I think that data analysis with differential privacy can be vastly more useful than
what you get after applying, for instance, the HIPAA safe harbor mechanism.&lt;/p&gt;

&lt;p&gt;My point is that there are many “win/win” applications of differential privacy where it simultaneously can give better utility and better privacy than its alternatives. As the CPUC case showed, sometimes the choice is even between no access at all and differentially private access. It’s really a no-brainer. We should start with such applications instead of arguing about completely unrestricted access versus differentially private access.&lt;/p&gt;

&lt;h3 id=&quot;dont-empower-the-naysayers&quot;&gt;Don’t empower the naysayers&lt;/h3&gt;

&lt;p&gt;In my opinion, for differential privacy to be a major success in practice it would be sufficient if it were  successful in &lt;em&gt;some&lt;/em&gt; applications but certainly not in &lt;em&gt;all&lt;/em&gt;—not even in most. There’s a culture of criticizing differential privacy based on the perfectly correct observation that some differentially private algorithm (say, Laplace) didn’t give enough utility in some application. These kind of observations—valid as they may be—say very little about the potential of differential privacy in practice. First of all, they only evaluate one algorithm while there could be much better algorithms. Second, they commit to one specific application and, more importantly, one particular modeling of the problem. Perhaps there’s a different approach to the same problem that’s more compatible with differential privacy. It’s simply impossible to rule out differential privacy as a solution through these kind of straw man experiments.&lt;/p&gt;

&lt;p&gt;The differential privacy community is partially at blame for empowering the naysayers, since they have advertised differential privacy as a &lt;em&gt;universal&lt;/em&gt; solution concept to the privacy problem. This is theoretically true in some sense, but the situation in practice is much more delicate. So, stop feeding the naysayers. Start presenting differential privacy as a promising technology for &lt;em&gt;some&lt;/em&gt; applications but certainly not &lt;em&gt;all&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;change-your-narrative&quot;&gt;Change your narrative&lt;/h3&gt;

&lt;p&gt;Don’t present differential privacy as a fear inducing crypto hammer
designed to obfuscate data access. That’s not what it is.
Differential privacy is a rigorous way of doing machine learning, not a way of
preventing machine learning from being done. We understand perfectly well now
that differential privacy is a stability guarantee which is fundamentally
aligned with the central goal of statistics, namely, to learn from data about the population
as a whole and not about specific individuals. This understanding perhaps wasn’t quite there
in the beginning, but it is now. Academics should from time to time come up
with a new page 1 for their papers.&lt;/p&gt;

&lt;h3 id=&quot;build-reliable-code-repositories&quot;&gt;Build reliable code repositories&lt;/h3&gt;

&lt;p&gt;A  weakness of the differential privacy community has been the scarcity of
available high quality code. There are many academic code pieces available
by emailing someone, but we don’t have many visible repositories on github
or elsewhere that provide robust implementations of common differentially
private algorithms. Frank McSherry’s &lt;a href=&quot;http://research.microsoft.com/en-us/projects/pinq/&quot;&gt;PINQ&lt;/a&gt; was a really wonderful step in the right direction,
but it is no longer maintained and by now out of date. Written in C#, it hasn’t been easy for many to build on and extend PINQ. A more recent notable effort is the &lt;a href=&quot;https://github.com/ejgallego/dualquery&quot;&gt;Dual Query&lt;/a&gt; code though it requires CPLEX to run.&lt;/p&gt;

&lt;p&gt;What scares me a bit is that even a project as solidly designed and carefully executed as PINQ
did not address low-level implementation issues such as &lt;a href=&quot;http://dl.acm.org/citation.cfm?id=2382264&quot;&gt;floating point vulnerabilities&lt;/a&gt; in differential privacy.&lt;/p&gt;

&lt;p&gt;I’m guilty myself. Many have used or tried to use &lt;a href=&quot;http://papers.nips.cc/paper/4548-a-simple-and-practical-algorithm-for-differentially-private-data-release.pdf&quot;&gt;MWEM&lt;/a&gt;, an algorithm Katrina Ligett, Frank McSherry and I presented at NIPS a few years ago. Yet we don’t have a great implementation publicly available. You can email us for a decent C# implementation (alas!), but instead a lot of people have
produced their own implementations of our algorithm over the years. I regularly have the urge to start an open source project for it, but then I realize it’s a bit of a bottomless pit. In order to have a solid implementation of MWEM, I’d first need to have a solid implementation of all the primitives with all the low-level issues that come up. In any case, if somebody more brave then myself took the first step on an open source effort (preferably not in C#), I’d be very eager to contribute.&lt;/p&gt;

&lt;p&gt;Taking a more modest step, I feel compelled to compile a list of available code repositories.
If you have any pointers, please leave a comment!&lt;/p&gt;

&lt;h3 id=&quot;be-less-general-and-more-domain-specific&quot;&gt;Be less general and more domain-specific&lt;/h3&gt;

&lt;p&gt;Much of the academic research on differential privacy has focused on generality. That makes sense theoretically, but it means that reading the scientific literature on differential privacy from the point of
view of a domain expert can be very frustrating. Most papers start with toy
examples that make perfect sense on a theoretical level, but will appear
alarmingly naïve to a domain expert.&lt;/p&gt;

&lt;p&gt;The community is at a point where we need to transition &lt;em&gt;from generality to specificity&lt;/em&gt;.
For example, what’s needed are domain-specific tutorials
that walk practitioners through real examples. One reason why such
tutorials don’t exist is that they take a lot of time and writing them isn’t
incentivized by academia. One way out of this is for journal editors and
conferences to specifically invite such tutorials. Similarly, the community should at this point have very high regard for positive results and case studies in specific application domains even if they are limited in scope and don’t contribute technically new solutions.&lt;/p&gt;

&lt;h3 id=&quot;be-more-entrepreneurial&quot;&gt;Be more entrepreneurial&lt;/h3&gt;

&lt;p&gt;The CPUC case highlighted that the application of differential privacy in
practice can fail as a result of many non-technical issues. These important
issues are often not on the radar of academic researchers. We spent an awful
lot of time talking about the technical strengths or limitations of
differential privacy, while missing out on some very real challenges. It’s quite reasonable to argue
that these challenges  should be outside the scope of academia. On the other hand, academics are currently the
only available experts on differential privacy and there’s obvious demand for it.
Where should we draw the line?&lt;/p&gt;

&lt;p&gt;To be blunt, I think an important ingredient that’s missing in the current differential
privacy ecosystem is &lt;em&gt;money&lt;/em&gt;. There is only so much that academic researchers can do to promote a technology.
Beyond a certain point businesses have to commercialize the technology for it be successful. The CPUC
case was much better suited as the full-time job for a group of paid professionals
rather than a volunteering effort. I’m surprised none of the researchers working on differential privacy
have devoted a sabbatical to running a privacy startup. It’s needed and the potential upside is big.
Why not give it a shot? I hear tenured jobs are meant for running startups.&lt;/p&gt;

&lt;h3 id=&quot;so-is-differential-privacy-practical&quot;&gt;So, is differential privacy practical?&lt;/h3&gt;

&lt;p&gt;I like the answer Aaron Roth gave when I asked him:&lt;/p&gt;

&lt;div style=&quot;text-align:center;&quot;&gt;
&lt;em&gt;It's within striking distance.&lt;/em&gt;
&lt;/div&gt;

</description>
        <pubDate>Fri, 13 Mar 2015 15:30:00 -0700</pubDate>
        <link>http://blog.mrtz.org/2015/03/13/practicing-differential-privacy.html</link>
        <guid isPermaLink="true">http://blog.mrtz.org/2015/03/13/practicing-differential-privacy.html</guid>
        
        <category>tcs</category>
        
        <category>differential privacy</category>
        
        <category>practice</category>
        
        
      </item>
    
      <item>
        <title>Competing in a data science contest without reading the data</title>
        <description>&lt;p&gt;Machine learning competitions have become an extremely popular format for
solving prediction and classification problems of all sorts. The most famous
example is perhaps the Netflix prize. An even better example is
&lt;a href=&quot;http://www.kaggle.com&quot;&gt;Kaggle&lt;/a&gt;, an awesome startup that’s
organized more than a hundred competitions over the past few years.&lt;/p&gt;

&lt;p&gt;The central component of any competition is the public leaderboard. Competitors can repeatedly submit a list of predictions and see how their predictions perform on a set of &lt;em&gt;holdout labels&lt;/em&gt; not available to them. The leaderboard ranks all teams according to their prediction accuracy on the holdout labels. Once the competition closes all teams are scored on a final test set not used so far. The resulting ranking, called private leaderboard, determines the winner.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/heritage-pub.jpg&quot; alt=&quot;Heritage Prize public leaderboard&quot; /&gt;&lt;/p&gt;

&lt;div style=&quot;text-align:center;margin-bottom:10px&quot;&gt;
Public leaderboard of the Heritage Health Prize (&lt;a href=&quot;http://www.heritagehealthprize.com/c/hhp/leaderboard/public&quot;&gt;Source&lt;/a&gt;)
&lt;/div&gt;

&lt;p&gt;In this post, I will describe a method to climb the public leaderboard &lt;em&gt;without even looking at the data&lt;/em&gt;. The algorithm is so simple and natural that an unwitting analyst might just run it. We will see that in Kaggle’s famous Heritage Health Prize competition this might have propelled a participant from rank around 150 into the top 10 on the public leaderboard without making progress on the actual problem. The Heritage Health Prize competition ran for two years and had a prize pool of 3 million dollars. Keep in mind though that the standings on the public leaderboard do not affect who gets the money.&lt;/p&gt;

&lt;p&gt;The point of this post is to illustrate why maintaining a leaderboard that accurately reflects the true performance of each team is a difficult and deep problem. While there are decades of work on estimating the true performance of a model (or set of models) from a finite sample, the leaderboard application highlights some
challenges that while fundamental have only recently seen increased attention. A follow-up post will describe a &lt;a href=&quot;http://arxiv.org/abs/1502.04585&quot;&gt;recent paper&lt;/a&gt; with Avrim Blum that gives an algorithm for maintaining a (provably) accurate public leaderboard.&lt;/p&gt;

&lt;p&gt;Let me be very clear that my point is &lt;em&gt;not&lt;/em&gt; to criticize Kaggle or anyone else organizing machine learning competitions. On the contrary, I’m amazed by how well Kaggle competitions work. In my opinion, they have contributed a tremendous amount of value to both industry and education. I also know that Kaggle has some very smart people thinking hard about how to anticipate problems with competitions.&lt;/p&gt;

&lt;h2 id=&quot;the-kaggle-leaderboard-mechanism&quot;&gt;The Kaggle leaderboard mechanism&lt;/h2&gt;

&lt;p&gt;At first sight, the Kaggle mechanism looks like the classic &lt;em&gt;holdout method&lt;/em&gt;. Kaggle partitions the data into two sets: a training set and a holdout set. The training set is publicly available with both the individual instances and their corresponding class labels. The instances of the holdout set are publicly available as well, but the class labels are withheld. Predicting these missing class labels is the goal of the participant and a valid submission is a list of labels—one for each point in the holdout set.&lt;/p&gt;

&lt;p&gt;Kaggle specifies a score function that maps a submission consisting of N labels to a numerical score, which we assume to be in &lt;script type=&quot;math/tex&quot;&gt;[0,1]&lt;/script&gt;. Think of the score as prediction error (smaller is better). For concreteness, let’s fix it to be the &lt;em&gt;misclassification rate&lt;/em&gt;. That is a prediction incurs loss 0 if it matches the corresponding unknown label and loss 1 if it does not match it. We divide by the number of predictions to get a score in &lt;script type=&quot;math/tex&quot;&gt;[0,1]&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Kaggle further splits its \(N\) private labels randomly into \(n\) holdout labels and \(N-n\) test labels. Typically, \(n=0.3N\). The public leaderboard is a sorting of all teams according to their score computed only on the \(n\) holdout labels (without using the test labels), while the private leaderboard is the ranking induced by the test labels.  I will let \(s_H(y)\) denote the public score of a submission \(y\), i.e., the score according to the public leaderboard. Typically, Kaggle rounds all scores to 5 or 6 digits of precision.&lt;/p&gt;

&lt;h2 id=&quot;the-cautionary-tale-of-wacky-boosting&quot;&gt;The cautionary tale of wacky boosting&lt;/h2&gt;

&lt;p&gt;Imagine your humble blogger in a parallel universe: I’m new to this whole machine learning craze. So, I sign up for a Kaggle competition to get some skills. Kaggle tells me that there’s an unknown set of labels \(y\in\{0,1\}^N\) that I need to predict. Well, I know nothing about \(y\). So here’s what I’m going to do. I try out a bunch of random vectors and keep all those that give me a slightly better than expected score. If we’re talking about misclassification rate, the expected score of a random binary vector is 0.5. So, I’m keeping all the vectors with score less than 0.5. Then I recall something about boosting. It tells me that I can boost my accuracy by aggregating all predictors into a single predictor using the majority function. Slightly more formally, here’s what I do:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Algorithm&lt;/strong&gt; (Wacky Boosting):&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Choose \(y_1,\dots,y_k\in\{0,1\}^N\) uniformly at random.&lt;/li&gt;
  &lt;li&gt;Let \(I = \{ i\in[k] \colon s_H(y_i) &amp;lt; 0.5 \}\).&lt;/li&gt;
  &lt;li&gt;Output \(\hat y=\mathrm{majority} \{ y_i \colon i \in I \} \), where the majority is component-wise.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Lo and behold, this is what happens:&lt;/p&gt;

&lt;div style=&quot;text-align:center&quot;&gt;
&lt;object data=&quot;/assets/boosting.svg&quot; type=&quot;image/svg+xml&quot;&gt;
&lt;param name=&quot;src&quot; value=&quot;/assets/boosting.svg&quot; /&gt;
  &lt;img src=&quot;/assets/boosting.png&quot; /&gt;
&lt;/object&gt;
&lt;p style=&quot;text-align:center&quot;&gt;In this plot, \(n=4000\) and all numbers are averaged over 5 independent repetitions.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;As I’m only seeing the public score (bottom red line), I get super excited. I keep climbing the leaderboard! Who would’ve thought that this machine learning thing was so easy? So, I go write a blog post on Medium about Big Data and score a job at DeepCompeting.ly, the latest data science startup in the city. Life is pretty sweet. I pick up indoor rock climbing, sign up for wood working classes; I read Proust and books about espresso. Two months later the competition closes and Kaggle releases the final score. What an embarrassment! Wacky boosting did nothing whatsoever on the final test set. I get fired from DeepCompeting.ly days before the buyout. My spouse dumps me. The lease expires. I get evicted from my apartment in the Mission. Inevitably, I hike the Pacific Crest Trail and write a novel about it.&lt;/p&gt;

&lt;h3 id=&quot;what-just-happened&quot;&gt;What just happened&lt;/h3&gt;

&lt;p&gt;Let’s understand what went wrong and how you can avoid hiking the Pacific Crest Trail. To start out with, each \(y_i\) has loss around \(1/2\pm1/\sqrt{n}\). We’re selecting the ones that are biased below a half. This introduces a bias in the score and the conditional expected bias of each selected vector \(w_i\) is roughly \(1/2-c/\sqrt{n}\) for some positive constant \(c&amp;gt;0\). Put differently, each selected \(y_i\) is giving us a guess about each label in the unknown holdout set \(H\subseteq [N]\) that’s correct with probability \(1/2 + \Omega(1/\sqrt{n})\). Since the public score doesn’t depend on labels outside of \(H\), the conditioning does not affect the final test set. The labels outside of \(H\) are still unbiased. Finally, we need to argue that the majority vote “boosts” our slightly biased coin tosses into a stronger bias. More formally, we can show that \(\hat y\) gives us a guess for each label in \(H\) that’s correct with probability
\[
\frac12 + \Omega\left(\sqrt{k/n}\right).
\]
Hence, the public score of \(y\) satisfies
\[
s_H(y) &amp;lt; \frac12 - \Omega\left(\sqrt{k/n}\right).
\]
Outside of \(H\), however, we’re just random guessing with no advantage.
To summarize, wacky boosting gives us &lt;em&gt;a bias of \(\sqrt{k}\) standard deviations on the public score with \(k\) submissions&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;What’s important is that the same algorithm still “works” even if we don’t get exact answers. All we need are answers that are accurate to an additive error of \(1/\sqrt{n}\). This is important since Kaggle rounds its answers to 5 digits of precision. In particular, this attack will work so long as \(n&amp;lt; 10^{10}\).&lt;/p&gt;

&lt;h3 id=&quot;why-the-holdout-method-breaks-down&quot;&gt;Why the holdout method breaks down&lt;/h3&gt;

&lt;p&gt;The idea behind the holdout method is that the holdout data serve as a fresh sample providing an unbiased and well-concentrated estimate of the true loss of the classifier on the underlying distribution. Why then didn’t the holdout method detect that our wacky boosting algorithm was overfitting? The short answer is that the holdout method is simply not valid in the way it’s used in a competition.&lt;/p&gt;

&lt;p&gt;One point of departure from the classic method is that the participants actually do see the data points corresponding to holdout labels which can lead to some problems. But that’s not the issue here and even if they we don’t look at the holdout data points at all, there’s a fundamental reason why the validity of the classic holdout method breaks down.&lt;/p&gt;

&lt;p&gt;The problem is that a submission in general incorporates information about the holdout labels previously released through the leaderboard mechanism. As a result, &lt;strong&gt;there is a statistical dependence between the holdout data and the submission&lt;/strong&gt;. Due to this feedback loop, the public score is in general no longer an unbiased estimate of the true score. There is no reason not to expect the submissions to eventually overfit to the holdout set.&lt;/p&gt;

&lt;p&gt;The problem of overfitting to the holdout set is well known. Kaggle’s forums are full of anecdotal evidence reported by various competitors. The primary way Kaggle deals with this problem is by limiting the rate of re-submission and (to some extent) the bit precision of the answers. Of course, this is also the reason why the winners are determined on a separate test set.&lt;/p&gt;

&lt;h3 id=&quot;static-vs-interactive-data-analysis&quot;&gt;Static vs interactive data analysis&lt;/h3&gt;

&lt;p&gt;Kaggle’s liberal use of the holdout method is just one example of a widespread disconnect between the theory of &lt;strong&gt;static data analysis&lt;/strong&gt; and the practice of &lt;strong&gt;interactive data analysis&lt;/strong&gt;. The holdout method is a static method in that it assumes the model to be independent of the holdout data on which it is evaluated. However, machine learning competitions are interactive, because submissions generally incorporate information from the holdout set.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/staticvsint.jpg&quot; alt=&quot;Static vs Interactive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I contend that most real world data analysis is interactive. Unfortunately, most of the theory on model validation and statistical estimation falls into the static setting requiring independence between method and holdout data. This divide is &lt;em&gt;not&lt;/em&gt; inherent though. Indeed, my next post deals with some useful theory for the interactive setting.&lt;/p&gt;

&lt;h2 id=&quot;the-heritage-health-prize-leaderboard&quot;&gt;The Heritage Health Prize leaderboard&lt;/h2&gt;

&lt;p&gt;Let’s see how this could’ve been applied to an actual competition. Of course, the &lt;a href=&quot;http://www.heritagehealthprize.com/c/hhp&quot;&gt;Heritage Health Prize&lt;/a&gt; competition is long over. We’re about two years too late to the party. Besides, we don’t have the solution file for that competition. Without it there’s no sure way of knowing how well this approach would’ve worked. Nevertheless, we can make some reasonable modeling of what the holdout labels might look like using information that was released by Kaggle and see how well we’d be doing against our random model.&lt;/p&gt;

&lt;h3 id=&quot;generalized-wacky-boosting&quot;&gt;Generalized wacky boosting&lt;/h3&gt;

&lt;p&gt;Before we can apply wacky boosting to the Heritage prize, we need to clear two obstacles.
First, wacky boosting required the domain to be Boolean whereas the labels could be arbitrary positive real numbers. Second, the algorithm only gave an advantage over random guessing which might be too far from the top of the leaderboard to start out with. It turns out that both of these issues can be resolved nicely with a simple generalization of the previous algorithm. What was really happening in the algorithm is that we had two candidate solutions, the all ones vector and the all zeros vector, and we tried out random coordinate-wise combinations of these vectors. The algorithm ends up finding a coordinate wise combination of the two vectors that improves upon their mean loss, i.e., one half. This way of looking at it generalizes nicely. The resulting algorithm is just a few lines of Julia code.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-julia&quot; data-lang=&quot;julia&quot;&gt;&lt;span class=&quot;c&quot;&gt;# select coordinate from v1 where v is 1 and from v2 where v is 0&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;combine&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.*&lt;/span&gt; &lt;span class=&quot;x&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt; wackyboost&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;score&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mean&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;score&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;score&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;)])&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;,(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# select columns of A that give better than mean score&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;score&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;combine&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;[:,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;,[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;])&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# take majority vote over all selected columns&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;[:,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ones&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;combine&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I worked through the fun exercise of applying this algorithm in a separate &lt;a href=&quot;http://nbviewer.ipython.org/gist/mrtzh/c41fd4c5897fc114a0d6&quot;&gt;Julia notebook&lt;/a&gt;. Here’s one picture that came out of it. Don’t treat the numbers as definitive as they all depend on the modeling assumptions I made.&lt;/p&gt;

&lt;div style=&quot;text-align:center&quot;&gt;
&lt;object data=&quot;/assets/heritage.svg&quot; type=&quot;image/svg+xml&quot;&gt;
  &lt;img src=&quot;/assets/heritage.png&quot; /&gt;
&lt;/object&gt;
&lt;p style=&quot;text-align:center&quot;&gt;We see an improvement from 0.462311 (rank 146) to 0.451868  (rank 6).&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;The bottom line is: It seems to work reasonably well (under various semi-principled modeling assumptions I made). From the looks of it this might have given you an improvement &lt;em&gt;from rank 150ish to 6ish&lt;/em&gt; within 700 submissions. Note there was a single team with 671 submissions. There’s a pretty good gap between number one on the &lt;a href=&quot;http://www.heritagehealthprize.com/c/hhp/leaderboard/public&quot;&gt;public leaderboard&lt;/a&gt; and the rest. While possible in principle, it took me a bunch more submissions to get to the top. I should say though that I used the completely generic code from above without any optimizations specific to the competition. I didn’t even look at the data points (as I don’t have them). It’s possible that using the data and domain knowledge could improve things much further. I chose the Heritage Health prize, because it was the highest prized Kaggle competition ever (3 million dollars) and it ran for two years with a substantial number of submissions.&lt;/p&gt;

&lt;h2 id=&quot;how-robust-is-your-benchmark&quot;&gt;How robust is your benchmark?&lt;/h2&gt;

&lt;p&gt;There’s a broad lesson to be learned from this example. As computer scientists we love numerical benchmarks and rankings of all sorts. They look so objective and scientific that we easily forget how any benchmark is just a proxy for a more complex question. Every once in a while we should step back and ask: How robust is the benchmark? Do improvements in our benchmark really correspond to progress on the original problem? What I’d love to see in all empirical branches of computer science are adversarial robustness evaluations of various benchmarks. How far can we get by &lt;em&gt;gaming&lt;/em&gt; rather than by actually making progress towards solving the problem?&lt;/p&gt;

&lt;p&gt;Let me end on a positive note. What excites me is that the serious problems we saw in this post actually do have a fix (both in theory and in practice)! So, stay tuned for my next post.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Subscribe to the  &lt;a href=&quot;http://blog.mrtz.org/feed.xml&quot;&gt;RSS feed&lt;/a&gt;
or follow me on &lt;a href=&quot;https://www.twitter.com/mrtz&quot;&gt;Twitter&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 09 Mar 2015 10:30:00 -0700</pubDate>
        <link>http://blog.mrtz.org/2015/03/09/competition.html</link>
        <guid isPermaLink="true">http://blog.mrtz.org/2015/03/09/competition.html</guid>
        
        <category>tcs</category>
        
        
      </item>
    
      <item>
        <title>Goodbye Wordpress, never again</title>
        <description>&lt;p&gt;Some may have noticed that this blog was an utter mess for about two weeks.
This was due to an exploited vulnerability in Wordpress leaving my blog 
in a state most curiously difficult to recover from. The only thing not
corrupted by this horrific cyberattack (possibly of North Korean origin) 
was an SQL database dump of my blog
that turned out to be inconsistent with a fresh Wordpress install. The
Wordpress support team thankfully pointed me to a number of videos
explaning carefully how to move my mouse
cursor from one point to another. I feel a lot more confident now with the mouse
cursor. In the
end, I more or less manually moved my blog to &lt;a href=&quot;http://jekyllrb.com&quot;&gt;Jekyll&lt;/a&gt; hosted by
&lt;a href=&quot;https://pages.github.com&quot;&gt;GitHub&lt;/a&gt; with &lt;a href=&quot;http://disqus.com&quot;&gt;Disqus&lt;/a&gt; comments.
It’s a pretty decent combination that a lot of people seem to be transitioning
to.&lt;/p&gt;

&lt;p&gt;If you ever think about starting a blog, &lt;em&gt;do not&lt;/em&gt; go with Wordpress. If you absolutely
cannot resist the temptation, by all means do not maintain your own Wordpress
install. Wordpress is slow, clunky and insecure. I had to install updates
multiple times a month and even that was evidently not enough to stay on top.&lt;/p&gt;

&lt;p&gt;On a positive note, I appear to be on paternity leave right now—for another
five weeks or so—and I hope to write a blog post or two in those moments
when I’m not spending quality time with my bicycles, ehm, and my daughter, of
course.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;To stay on top of future posts, subscribe to the (new) &lt;a href=&quot;http://blog.mrtz.org/feed.xml&quot;&gt;RSS feed&lt;/a&gt;
or follow me on &lt;a href=&quot;https://www.twitter.com/mrtz&quot;&gt;Twitter&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 08 Feb 2015 11:45:39 -0800</pubDate>
        <link>http://blog.mrtz.org/2015/02/08/wordpress.html</link>
        <guid isPermaLink="true">http://blog.mrtz.org/2015/02/08/wordpress.html</guid>
        
        <category>tcs</category>
        
        
      </item>
    
      <item>
        <title>The NIPS Experiment</title>
        <description>&lt;p&gt;&lt;em&gt;This is a guest post by &lt;a href=&quot;http://cs.utexas.edu/~ecprice/&quot;&gt;Eric Price&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I was at NIPS (one of the two main machine learning conferences) in Montreal last week, which has a really advanced format relative to the theory conferences. The double blind reviewing, rebuttal phase, and poster+lightning talk system all seem like improvements on the standard in my normal area (theoretical computer science), and having 2400 attendees is impressive and overwhelming. But the most amazing thing about the conference organization this year was the &lt;a href=&quot;http://inverseprobability.com/2014/12/16/the-nips-experiment/&quot;&gt;NIPS consistency experiment&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A perennial question for academics is how accurate the conference review and acceptance process is. Getting papers into top conferences is hugely important for our careers, yet we all have papers rejected that we think should have gotten in. One of my papers was rejected three times before getting into SODA – as the best student paper. After rejections, we console ourselves that the reviewing process is random; yet we take acceptances as confirmation that our papers are good. So just how random &lt;em&gt;is&lt;/em&gt; the reviewing process?  The NIPS organizers decided to find out.&lt;/p&gt;

&lt;h2 id=&quot;the-nips-experiment&quot;&gt;The NIPS Experiment&lt;/h2&gt;

&lt;p&gt;The NIPS consistency experiment was an amazing, courageous move by the organizers this year to quantify the randomness in the review process. They split the program committee down the middle, effectively forming two independent program committees. Most submitted papers were assigned to a single side, but 10% of submissions (166) were reviewed by &lt;em&gt;both&lt;/em&gt; halves of the committee. This let them observe how consistent the two committees were on which papers to accept.  (For fairness, they ultimately accepted any paper that was accepted by either committee.)&lt;/p&gt;

&lt;p&gt;The results were revealed this week: of the 166 papers, the two committees disagreed on the fates of 25.9% of them: 43. [Update: the original post said 42 here, but I misremembered.] But this “25%” number is misleading, and most people I’ve talked to have misunderstood it: it actually means that the two committees &lt;em&gt;disagreed more than they agreed&lt;/em&gt; on which papers to accept. Let me explain.&lt;/p&gt;

&lt;p&gt;The two committees were each tasked with a 22.5% acceptance rate. This would mean choosing about 37 or 38 of the 166 papers to accept&lt;sup&gt;&lt;a href=&quot;#footnotes&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;. Since they disagreed on 43 papers total, this means one committee accepted 21 papers that the other committee rejected and the other committee accepted 22 papers the first rejected, for 21 + 22 = 43 total papers with different outcomes. Since they accepted 37 or 38 papers, this means they disagreed on 21/37 or 22/38 ≈ 57% of the list of accepted papers.&lt;/p&gt;

&lt;p&gt;In particular, about 57% of the papers accepted by the first committee were rejected by the second one and vice versa. In other words, most papers at NIPS would be rejected if one reran the conference review process (with a 95% confidence interval of 40-75%):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/nips-pie11.png&quot; alt=&quot;Nips pie chart&quot; /&gt;&lt;/p&gt;

&lt;p style=&quot;text-align: center&quot;&gt;Most papers accepted by one committee were rejected by the other, and vice versa.&lt;/p&gt;

&lt;p&gt;This result was surprisingly large to most people I’ve talked to; they generally expected something like 30% instead of 57%. Relative to what people expected, 57% is actually closer to a purely random committee, which would only disagree on 77.5% of the accepted papers on average:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/randomgraph2.png&quot; alt=&quot;Random model&quot; /&gt;&lt;/p&gt;

&lt;p style=&quot;text-align: center&quot;&gt;
If the committees were purely random, at a 22.5%
acceptance rate&lt;br /&gt; they would disagree on 77.5% of their acceptance lists on average.&lt;/p&gt;

&lt;p&gt;In the next section, I’ll discuss a couple simple models for the conference review process that give the observed level of randomness.&lt;/p&gt;

&lt;h2 id=&quot;models-for-conference-acceptance&quot;&gt;Models for conference acceptance&lt;/h2&gt;

&lt;p&gt;One rough model for paper acceptance, consistent with the experiment, is as follows:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Half the submissions are found to be poor and reliably rejected.&lt;/li&gt;
  &lt;li&gt;The other half are accepted based on an unbiased coin flip.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This might be a decent rule of thumb, but it’s clearly missing something: some really good papers do have a chance of acceptance larger than one half.&lt;/p&gt;

&lt;h3 id=&quot;the-messy-middle-model&quot;&gt;The “messy middle” model&lt;/h3&gt;

&lt;p&gt;One simple extension to the above model is the “messy middle” model, where some papers are clear accepts; some papers are clear rejects; and the papers in the middle are largely random.   We can compute what kinds of parameters are consistent with the NIPS experiment.  Options include:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;The above model.&lt;/strong&gt; Half the papers are clear rejects, and everything else is random.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;The opposite.&lt;/strong&gt; 7% of all papers (i.e. 30% of accepted papers) are clear accepts, and the  other 93% are random.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Somewhere in the middle.&lt;/strong&gt; For example 6% of all papers (i.e. 25% of accepted papers) are clear accepts, 25% of submitted papers are clear rejects, and the rest are random.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/messymiddle.png&quot; alt=&quot;Messy middle&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;the-noisy-scoring-model&quot;&gt;The “noisy scoring” model&lt;/h3&gt;

&lt;p&gt;As I was discussing this over dinner, Jacob Abernethy proposed a “noisy scoring” model based on his experience as an area chair. Each paper typically gets three reviews, each giving a score on 0-10. The committee uses the average score&lt;sup&gt;&lt;a href=&quot;#footnotes&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; as the main signal for paper quality. As I understand it, the basic committee process was that almost everything above 6.5 was accepted, almost everything below 6 was rejected, and the committee mainly debated the papers in between.&lt;/p&gt;

&lt;p&gt;A basic simplified model of this would be as follows. Each paper has a “true”
score \(v\) drawn from some distribution (say, \({N(0,
\sigma_{between}^2)}\)), and the the reviews for the paper are drawn
from \(N(v, \sigma_{within}^2)\). Then the NIPS experiment’s
result (number of papers in which the two committees disagree) is a function
of the ratio \(\sigma_{between}/\sigma_{within}\). We find that
the observation would be consistent with this model if
\(\sigma_{within}\) is between one and four times \(\sigma_{between}\):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/noisyscoring2.png&quot; alt=&quot;Noisy scoring&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Once the NIPS review data is released, we can check the empirical
\({\sigma_{within}}\) and \({\sigma_{between}}\) to see if this model is reasonable.&lt;/p&gt;

&lt;p&gt;One nice thing about the noisy scoring model is that you don’t actually need to run the NIPS experiment to estimate the parameters. Every CS conference could measure the within-paper and between-paper variance in reviewer scores. This lets you measure the expected randomness in the results of the process, assuming the model holds.&lt;/p&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;Computer science conference acceptances seem to be more random than we had previously realized. This suggests that we should rethink the importance we give to them in terms of the job search, tenure process, etc.&lt;/p&gt;

&lt;p&gt;I’ll close with a few final thoughts:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Consistency is not the only goal. Double-blind reviewing probably decreases consistency by decreasing the bias towards established researchers, but this is a good thing and the TCS conferences should adopt the system.&lt;/li&gt;
  &lt;li&gt;Experiments are good! As scientists, we ought to do more experiments on our processes. The grad school admissions process seems like a good target for this, for example.&lt;/li&gt;
  &lt;li&gt;I’d like to give a &lt;em&gt;huge&lt;/em&gt; shout-out to the NIPS organizers, Corinna Cortes and Neil Lawrence, for running this experiment. It wasn’t an easy task – not only did they review 10% more papers than necessary, they also had the overhead of finding and running two independent PCs. But the results are valuable for the whole computer science community.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;footnotes&quot;&gt;Footnotes&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;The committees did not know which of the ~900 papers they were reviewing were the 166 duplicated ones, so there can be some variation in how many papers to accept, but this is a minor effect.&lt;/li&gt;
  &lt;li&gt;They also use a “confidence-weighted” score, but let’s ignore that detail.&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Mon, 15 Dec 2014 11:45:39 -0800</pubDate>
        <link>http://blog.mrtz.org/2014/12/15/the-nips-experiment.html</link>
        <guid isPermaLink="true">http://blog.mrtz.org/2014/12/15/the-nips-experiment.html</guid>
        
        <category>tcs</category>
        
        
      </item>
    
      <item>
        <title>How big data is unfair</title>
        <description>&lt;p&gt;Head on over to &lt;a href=&quot;https://medium.com/@mrtz/how-big-data-is-unfair-9aa544d739de&quot;&gt;Medium&lt;/a&gt;
for a non-technical general audience piece I wrote on &lt;em&gt;why machine learning is not, by
default, fair or just in any meaningful way.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Since I first wrote this post there’s been some interesting follow up by
&lt;a href=&quot;https://medium.com/@hannawallach/big-data-machine-learning-and-the-social-sciences-927a8e20460d&quot;&gt;Hanna
Wallach&lt;/a&gt;.
Also be sure to check out the web site of the &lt;a href=&quot;http://www.fatml.org&quot;&gt;NIPS workshop&lt;/a&gt; on fairness,
accountability and transparency that Solon Barocas and I organized.&lt;/p&gt;
</description>
        <pubDate>Fri, 26 Sep 2014 18:02:37 -0700</pubDate>
        <link>http://blog.mrtz.org/2014/09/26/how-big-data-is-unfair.html</link>
        <guid isPermaLink="true">http://blog.mrtz.org/2014/09/26/how-big-data-is-unfair.html</guid>
        
        
      </item>
    
      <item>
        <title>Robustness versus Acceleration</title>
        <description>&lt;p&gt;My blog post on the &lt;a href=&quot;http://mrtz.org/blog/the-zen-of-gradient-descent/&quot;&gt;Zen of Gradient Descent&lt;/a&gt; hit the front page of &lt;a href=&quot;https://news.ycombinator.com/item?id=8182991&quot;&gt;Hacker News&lt;/a&gt; the other day. I don't know how that happened. It got me more views in one day than this most humble blog usually gets in half a year. I thought I should take this as an excuse to extend the post a bit by elaborating on one remark I made only in passing. You don't need to go back to reading that post unless you want to. This one will be self contained.&lt;/p&gt;
&lt;p&gt;The point I made is that basic Gradient Descent (GD) is noise tolerant in a way that Accelerated Gradient Descent (AGD) is not. That is to say, if we don't have exact but rather approximate gradient information, GD might very well outperform AGD even though its convergence rate is worse in the exact setting. The truth is I was sort of bluffing. I didn't actually have a proof of a formal statement that would nail down this point in a compelling way. It was more of a gut feeling based on some simple observations.&lt;/p&gt;
&lt;p&gt;To break the suspense, I still haven't proved the statement I vaguely thought was true back then, but fortunately somebody else had already done that. This is a thought provoking &lt;a href=&quot;http://www.optimization-online.org/DB_FILE/2010/12/2865.pdf&quot;&gt;paper by Devolder, Glineur and Nesterov &lt;/a&gt;(DGN). Thanks to Cristobal Guzman for pointing me to this paper. Roughly, what they show is that any method that converges faster than the basic gradient descent method must accumulate errors linearly with the number of iterations. Hence, in various noisy settings auch as are common in applications acceleration may not help---in fact, it can actually make things worse!&lt;/p&gt;
&lt;p&gt;I'll make this statement more formal below, but let me first explain why I love this result. There is a tendency in algorithm design to optimize computational efficiency first, second and third and then maybe think about some other stuff as sort of an add-on constraint. We generally tend to equate faster with better. The reason why this is not a great methodology is that sometimes acceleration is mutually exclusive with other fundamental design goals. A theory that focuses primarily on speedups without discussing trade-offs with robustness misses a pretty important point.&lt;/p&gt;
&lt;h2&gt;When acceleration is good&lt;/h2&gt;
&lt;p&gt;Let's build some intuition for the result I mentioned before we go into formal details. Consider my favorite example of minimizing a smooth convex function \({f\colon \mathbb{R}^n\rightarrow\mathbb{R}}\) defined as&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;\(\displaystyle f(x) = \frac 12 x^T L x - b^T x \)&lt;/p&gt;
&lt;p&gt;for some positive semidefinite \({n\times n}\) matrix \({L}\) and a vector \({b\in\mathbb{R}^n.}\) Recall that the gradient is \({\nabla f(x)=Lx-b.}\) An illustrative example is the &lt;a href=&quot;http://en.wikipedia.org/wiki/Laplacian_matrix&quot;&gt;Laplacian &lt;/a&gt; of a &lt;a href=&quot;http://en.wikipedia.org/wiki/Cycle_graph&quot;&gt;cycle graph&lt;/a&gt;:&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;\(\displaystyle L = \left[ \begin{array}{ccccccc} 2 &amp;amp; -1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; \cdots &amp;amp; -1 \\ -1 &amp;amp; 2 &amp;amp; -1 &amp;amp; 0 &amp;amp; 0 &amp;amp; \cdots &amp;amp; 0 \\ 0 &amp;amp; -1 &amp;amp; 2 &amp;amp; -1&amp;amp; 0 &amp;amp; \cdots &amp;amp; 0 \\ \vdots &amp;amp; &amp;amp; &amp;amp; &amp;amp; &amp;amp; &amp;amp; \end{array} \right] \)&lt;/p&gt;
&lt;p&gt;Since \({L}\) is positive semidefinite like any graph Laplacian, the function \({f}\) is convex. The operator norm of \({L}\) is bounded by~\({4}\) and so we have that for all \({x,y\in\mathbb{R}^n:}\)&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;\(\displaystyle \|\nabla f(x) -\nabla f(y)\| \le \|L\|\cdot\|x-y\|\le 4 \|x-y\|. \)&lt;/p&gt;
&lt;p&gt;This means the function is also smooth and we can apply AGD/GD with a suitable step size. Comparing AGD and GD on this instance with \({n=100}\), we get the following picture:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/no-noise.png&quot; alt=&quot;No noise&quot; /&gt;&lt;/p&gt;

&lt;p&gt;It looks like AGD is the clear winner. GD is pretty slow and takes a few thousand iterations to decrease the error by an order of magnitude.&lt;/p&gt;
&lt;h2&gt;When acceleration is bad&lt;/h2&gt;
&lt;p&gt;The situation changes dramatically in the presence of noise. Let's repeat the exact same experiment but now instead of observing \({\nabla f(x)}\) for any given \({x,}\) we can only see \({\nabla f(x) + \xi}\) where \({\xi}\) is sampled from the \({n}\)-dimensional normal distribution \({N(0,\sigma^2)^n.}\) Choosing \({\sigma=0.1}\) we get the following picture:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/with-noise.png&quot; alt=&quot;With noise&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Gradient descent pretty quickly converges to essentially the best result that we can hope for given the noisy gradients. In contrast, AGD goes totally nuts. It doesn't converge at all and it adds up errors in sort of linear fashion. In this world, GD is the clear winner.&lt;/p&gt;

&lt;h2&gt;A precise trade-off&lt;/h2&gt;
&lt;p&gt;The first thing DGN do in their paper is to define a general notion of inexact first order oracle. Let's recall what an exact first-order oracle does for an (unconstrained) convex function \({f\colon\mathbb{R}^n\rightarrow \mathbb{R}}\) with smoothness parameter \({L.}\) Given any point \({x\in\mathbb{R}^n}\) an exact first order oracle returns a pair \({(f_L(x),g_L(x))\in\mathbb{R}\times\mathbb{R}^n}\) so that for all \({y\in\mathbb{R}^n}\) we have&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;\(\displaystyle 0\le f(y) - \big(f_L(x) + \langle g_L(x),y-x\rangle\big)\le \frac L2\|y-x\|^2\,. \)&lt;/p&gt;
&lt;p&gt;Pictorially, at every point \({x}\) the function can be sandwiched between a tangent linear function specified by \({(f_L(x),g_L(x))}\) and a parabola. The pair \({(f(x),\nabla f(x))}\) satisfies this constraint as the first inequality follows from convexity and the second from the smoothness condition. In fact, this pair is the only pair that satisfies these conditions. My slightly cumbersome way of desribing a first-order oracle was only so that we may now easily generalize it to an inexact first-order oracle. Specifically, an inexact oracle returns for any given point \({x\in\mathbb{R}^n}\) a pair \({(f_{\delta,L}(x),g_{\delta,L}(x))\in\mathbb{R}\times\mathbb{R}^n}\) so that for all \({y\in\mathbb{R}^n}\) we have&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;\(\displaystyle 0\le f(y) - \big(f_{\delta,L}(x) + \langle g_{\delta,L}(x),y-x\rangle\big)\le \frac L2\|y-x\|^2+\delta\,. \)&lt;/p&gt;
&lt;p&gt;It's the same picture as before except now there's some \({\delta}\) slack between the linear approximation and the parabola.&lt;br /&gt;
With this notion at hand, what DGN show is that given access to \({\delta}\)-inexact first-order oracle Gradient Descent spits out a point \({x^t}\) after \({t}\) steps so that&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;\(\displaystyle f(x^t) - \min_x f(x) \le O\big(L/t\big) + \delta\,. \)&lt;/p&gt;
&lt;p&gt;The big-oh notation is hiding the squared distance between the optimum and the starting point. Accelerated Gradient Descent on the other hand gives you&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;\(\displaystyle f(x^t) - \min_x f(x) \le O\big(L/t^2\big) + O\big(t \delta\big)\,. \)&lt;/p&gt;
&lt;p&gt;Moreover, you cannot improve this-tradeoff between acceleration and error accumulation. That is any method that converges as \({1/t^2}\) must accumulate errors as \({t\delta.}\)&lt;/p&gt;
&lt;h2&gt;Open questions&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;The lower bound I just mentioned in the previous paragraph stems from the fact that an inexact first-order oracle can embed non-smooth optimization problems for which a speedup is not possible. This is interesting, but it doesn't resolve, for example, the question of whether there could be a speedup in the simple gaussian noise addition model that I mentioned above. This isn't even a toy model---as you might object---since gaussian noise addition is what you would do to make gradient descent privacy preserving. See for example an upcoming FOCS &lt;a href=&quot;http://arxiv.org/pdf/1405.7085.pdf&quot;&gt;paper by Bassily, Smith, Thakurta&lt;/a&gt; for an analysis of gradient descent with gaussian noise.&lt;/li&gt;
&lt;li&gt;Is there an analog of the DGN result in the eigenvalue world? More formally, can we show that any Krylov subspace method that converges asymptotically faster than the &lt;a href=&quot;http://mrtz.org/blog/power-method/&quot;&gt;power method&lt;/a&gt; must accumulate errors?&lt;/li&gt;
&lt;li&gt;The cycle example above is often used to show that any blackbox gradient method requires at least \({t\ge \Omega(1/\sqrt{\epsilon})}\) steps to converge to error \({\epsilon}\) provided that \({t}\) is less than the number of vertices of the cycle, that is the dimension \({n}\) of the domain. (See, for example, Theorem 3.9. in Sebastien Bubeck's &lt;a href=&quot;http://arxiv.org/pdf/1405.4980v1.pdf&quot;&gt;book&lt;/a&gt;.) Are there any lower bounds that hold for \({t\gg n}\)?&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Pointers:&lt;/h2&gt;
&lt;p&gt;The code for these examples is available &lt;a href=&quot;http://nbviewer.ipython.org/gist/mrtzh/4dc77fb84c3ba8b8b220&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;em&gt;To stay on top of future posts, subscribe to the &lt;a style=&quot;color: #bc360a;&quot; href=&quot;http://mrtz.org/blog/feed/&quot;&gt;RSS feed&lt;/a&gt; or follow me on &lt;a style=&quot;color: #bc360a;&quot; href=&quot;http://twitter.com/mrtz&quot;&gt;Twitter&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 18 Aug 2014 12:31:57 -0700</pubDate>
        <link>http://blog.mrtz.org/2014/08/18/robustness-versus-acceleration.html</link>
        <guid isPermaLink="true">http://blog.mrtz.org/2014/08/18/robustness-versus-acceleration.html</guid>
        
        <category>algorithms</category>
        
        <category>tcs</category>
        
        <category>complexity</category>
        
        <category>theory</category>
        
        <category>gradient descent</category>
        
        <category>convexity</category>
        
        <category>optimization</category>
        
        <category>robustness</category>
        
        
      </item>
    
  </channel>
</rss>
