<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Competing in a data science contest without reading the data</title>
  <meta name="description" content="Machine learning competitions have become an extremely popular format forsolving prediction and classification problems of all sorts. The most famousexample ...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="blog.mrtz.org/2015/03/09/competition.html">
  <link rel="alternate" type="application/rss+xml" title="Moody Rd" href="blog.mrtz.org/feed.xml" />
</head>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> 


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Moody Rd</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Competing in a data science contest without reading the data</h1>
    <p class="post-meta">Mar 9, 2015 • Moritz Hardt</p>
  </header>

  <article class="post-content">
    <p>Machine learning competitions have become an extremely popular format for
solving prediction and classification problems of all sorts. The most famous
example is perhaps the Netflix prize. An even better example is
<a href="http://www.kaggle.com">Kaggle</a>, an awesome startup that’s
organized more than a hundred competitions over the past few years.</p>

<p>The central component of any competition is the public leaderboard. Competitors can repeatedly submit a list of predictions and see how their predictions perform on a set of <em>holdout labels</em> not available to them. The leaderboard ranks all teams according to their prediction accuracy on the holdout labels. Once the competition closes all teams are scored on a final test set not used so far. The resulting ranking, called private leaderboard, determines the winner.</p>

<p><img src="/assets/heritage-pub.jpg" alt="Heritage Prize public leaderboard" /></p>

<div style="text-align:center;margin-bottom:10px">
Public leaderboard of the Heritage Health Prize (<a href="http://www.heritagehealthprize.com/c/hhp/leaderboard/public">Source</a>)
</div>

<p>In this post, I will describe a method to climb the public leaderboard <em>without even looking at the data</em>. The algorithm is so simple and natural that an unwitting analyst might just run it. We will see that in Kaggle’s famous Heritage Health Prize competition this might have propelled a participant from rank around 150 into the top 10 on the public leaderboard without making progress on the actual problem. The Heritage Health Prize competition ran for two years and had a prize pool of 3 million dollars. Keep in mind though that the standings on the public leaderboard do not affect who gets the money.</p>

<p>The point of this post is to illustrate why maintaining a leaderboard that accurately reflects the true performance of each team is a difficult and deep problem. While there are decades of work on estimating the true performance of a model (or set of models) from a finite sample, the leaderboard application highlights some
challenges that while fundamental have only recently seen increased attention. A follow-up post will describe a <a href="http://arxiv.org/abs/1502.04585">recent paper</a> with Avrim Blum that gives an algorithm for maintaining a (provably) accurate public leaderboard.</p>

<p>Let me be very clear that my point is <em>not</em> to criticize Kaggle or anyone else organizing machine learning competitions. On the contrary, I’m amazed by how well Kaggle competitions work. In my opinion, they have contributed a tremendous amount of value to both industry and education. I also know that Kaggle has some very smart people thinking hard about how to anticipate problems with competitions.</p>

<h2 id="the-kaggle-leaderboard-mechanism">The Kaggle leaderboard mechanism</h2>

<p>At first sight, the Kaggle mechanism looks like the classic <em>holdout method</em>. Kaggle partitions the data into two sets: a training set and a holdout set. The training set is publicly available with both the individual instances and their corresponding class labels. The instances of the holdout set are publicly available as well, but the class labels are withheld. Predicting these missing class labels is the goal of the participant and a valid submission is a list of labels—one for each point in the holdout set.</p>

<p>Kaggle specifies a score function that maps a submission consisting of N labels to a numerical score, which we assume to be in [0,1]. Think of the score as prediction error (smaller is better). For concreteness, let’s fix it to be the <em>misclassification rate</em>. That is a prediction incurs loss 0 if it matches the corresponding unknown label and loss 1 if it does not match it. We divide by the number of predictions to get a score in [0,1].</p>

<p>Kaggle further splits its \(N\) private labels randomly into \(n\) holdout labels and \(N-n\) test labels. Typically, \(n=0.3N\). The public leaderboard is a sorting of all teams according to their score computed only on the \(n\) holdout labels (without using the test labels), while the private leaderboard is the ranking induced by the test labels.  I will let \(s_H(y)\) denote the public score of a submission \(y\), i.e., the score according to the public leaderboard. Typically, Kaggle rounds all scores to 5 or 6 digits of precision.</p>

<h2 id="the-cautionary-tale-of-wacky-boosting">The cautionary tale of wacky boosting</h2>

<p>Imagine your humble blogger in a parallel universe: I’m new to this whole machine learning craze. So, I sign up for a Kaggle competition to get some skills. Kaggle tells me that there’s an unknown set of labels \(y\in\{0,1\}^N\) that I need to predict. Well, I know nothing about \(y\). So here’s what I’m going to do. I try out a bunch of random vectors and keep all those that give me a slightly better than expected score. If we’re talking about misclassification rate, the expected score of a random binary vector is 0.5. So, I’m keeping all the vectors with score less than 0.5. Then I recall something about boosting. It tells me that I can boost my accuracy by aggregating all predictors into a single predictor using the majority function. Slightly more formally, here’s what I do:</p>

<p><strong>Algorithm</strong> (Wacky Boosting):</p>

<ol>
  <li>Choose \(y_1,\dots,y_k\in\{0,1\}^N\) uniformly at random.</li>
  <li>Let \(I = \{ i\in[k] \colon s_H(y_i) &lt; 0.5 \}\).</li>
  <li>Output \(\hat y=\mathrm{majority} \{ y_i \colon i \in I \} \), where the majority is component-wise.</li>
</ol>

<p>Lo and behold, this is what happens:</p>

<div style="text-align:center">
<object data="/assets/boosting.svg" type="image/svg+xml">
<param name="src" value="/assets/boosting.svg" />
  <img src="/assets/boosting.png" />
</object>
<p style="text-align:center">In this plot, \(n=4000\) and all numbers are averaged over 5 independent repetitions.</p>
</div>

<p>As I’m only seeing the public score (bottom red line), I get super excited. I keep climbing the leaderboard! Who would’ve thought that this machine learning thing was so easy? So, I go write a blog post on Medium about Big Data and score a job at DeepCompeting.ly, the latest data science startup in the city. Life is pretty sweet. I pick up indoor rock climbing, sign up for wood working classes; I read Proust and books about espresso. Two months later the competition closes and Kaggle releases the final score. What an embarrassment! Wacky boosting did nothing whatsoever on the final test set. I get fired from DeepCompeting.ly days before the buyout. My spouse dumps me. The lease expires. I get evicted from my apartment in the Mission. Inevitably, I hike the Pacific Crest Trail and write a novel about it.</p>

<h3 id="what-just-happened">What just happened</h3>

<p>Let’s understand what went wrong and how you can avoid hiking the Pacific Crest Trail. To start out with, each \(y_i\) has loss around \(1/2\pm1/\sqrt{n}\). We’re selecting the ones that are biased below a half. This introduces a bias in the score and the conditional expected bias of each selected vector \(w_i\) is roughly \(1/2-c/\sqrt{n}\) for some positive constant \(c&gt;0\). Put differently, each selected \(y_i\) is giving us a guess about each label in the unknown holdout set \(H\subseteq [N]\) that’s correct with probability \(1/2 + \Omega(1/\sqrt{n})\). Since the public score doesn’t depend on labels outside of \(H\), the conditioning does not affect the final test set. The labels outside of \(H\) are still unbiased. Finally, we need to argue that the majority vote “boosts” our slightly biased coin tosses into a stronger bias. More formally, we can show that \(\hat y\) gives us a guess for each label in \(H\) that’s correct with probability
\[
\frac12 + \Omega\left(\sqrt{k/n}\right).
\]
Hence, the public score of \(y\) satisfies
\[
s_H(y) &lt; \frac12 - \Omega\left(\sqrt{k/n}\right).
\]
Outside of \(H\), however, we’re just random guessing with no advantage.
To summarize, wacky boosting gives us <em>a bias of \(\sqrt{k}\) standard deviations on the public score with \(k\) submissions</em>.</p>

<p>What’s important is that the same algorithm still “works” even if we don’t get exact answers. All we need are answers that are accurate to an additive error of \(1/\sqrt{n}\). This is important since Kaggle rounds its answers to 5 digits of precision. In particular, this attack will work so long as \(n&lt; 10^{10}\).</p>

<h3 id="why-the-holdout-method-breaks-down">Why the holdout method breaks down</h3>

<p>The idea behind the holdout method is that the holdout data serve as a fresh sample providing an unbiased and well-concentrated estimate of the true loss of the classifier on the underlying distribution. Why then didn’t the holdout method detect that our wacky boosting algorithm was overfitting? The short answer is that the holdout method is simply not valid in the way it’s used in a competition.</p>

<p>One point of departure from the classic method is that the participants actually do see the data points corresponding to holdout labels which can lead to some problems. But that’s not the issue here and even if they we don’t look at the holdout data points at all, there’s a fundamental reason why the validity of the classic holdout method breaks down.</p>

<p>The problem is that a submission in general incorporates information about the holdout labels previously released through the leaderboard mechanism. As a result, <strong>there is a statistical dependence between the holdout data and the submission</strong>. Due to this feedback loop, the public score is in general no longer an unbiased estimate of the true score. There is no reason not to expect the submissions to eventually overfit to the holdout set.</p>

<p>The problem of overfitting to the holdout set is well known. Kaggle’s forums are full of anecdotal evidence reported by various competitors. The primary way Kaggle deals with this problem is by limiting the rate of re-submission and (to some extent) the bit precision of the answers. Of course, this is also the reason why the winners are determined on a separate test set.</p>

<h3 id="static-vs-interactive-data-analysis">Static vs interactive data analysis</h3>

<p>Kaggle’s liberal use of the holdout method is just one example of a widespread disconnect between the theory of <strong>static data analysis</strong> and the practice of <strong>interactive data analysis</strong>. The holdout method is a static method in that it assumes the model to be independent of the holdout data on which it is evaluated. However, machine learning competitions are interactive, because submissions generally incorporate information from the holdout set.</p>

<p><img src="/assets/staticvsint.jpg" alt="Static vs Interactive" /></p>

<p>I contend that most real world data analysis is interactive. Unfortunately, most of the theory on model validation and statistical estimation falls into the static setting requiring independence between method and holdout data. This divide is <em>not</em> inherent though. Indeed, my next post deals with some useful theory for the interactive setting.</p>

<h2 id="the-heritage-health-prize-leaderboard">The Heritage Health Prize leaderboard</h2>

<p>Let’s see how this could’ve been applied to an actual competition. Of course, the <a href="http://www.heritagehealthprize.com/c/hhp">Heritage Health Prize</a> competition is long over. We’re about two years too late to the party. Besides, we don’t have the solution file for that competition. Without it there’s no sure way of knowing how well this approach would’ve worked. Nevertheless, we can make some reasonable modeling of what the holdout labels might look like using information that was released by Kaggle and see how well we’d be doing against our random model.</p>

<h3 id="generalized-wacky-boosting">Generalized wacky boosting</h3>

<p>Before we can apply wacky boosting to the Heritage prize, we need to clear two obstacles.
First, wacky boosting required the domain to be Boolean whereas the labels could be arbitrary positive real numbers. Second, the algorithm only gave an advantage over random guessing which might be too far from the top of the leaderboard to start out with. It turns out that both of these issues can be resolved nicely with a simple generalization of the previous algorithm. What was really happening in the algorithm is that we had two candidate solutions, the all ones vector and the all zeros vector, and we tried out random coordinate-wise combinations of these vectors. The algorithm ends up finding a coordinate wise combination of the two vectors that improves upon their mean loss, i.e., one half. This way of looking at it generalizes nicely. The resulting algorithm is just a few lines of Julia code.</p>

<div class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="c"># select coordinate from v1 where v is 1 and from v2 where v is 0</span>
<span class="n">combine</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">)</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">.*</span> <span class="n">v</span> <span class="o">+</span> <span class="n">v2</span> <span class="o">.*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">v</span><span class="p">)</span>

<span class="k">function</span><span class="nf"> wackyboost</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">score</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">mean</span><span class="p">([</span><span class="n">score</span><span class="p">(</span><span class="n">v1</span><span class="p">),</span><span class="n">score</span><span class="p">(</span><span class="n">v2</span><span class="p">)])</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,(</span><span class="n">length</span><span class="p">(</span><span class="n">v1</span><span class="p">),</span><span class="n">k</span><span class="p">))</span>
    <span class="c"># select columns of A that give better than mean score</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">filter</span><span class="p">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">score</span><span class="p">(</span><span class="n">combine</span><span class="p">(</span><span class="n">A</span><span class="p">[:,</span><span class="n">i</span><span class="p">],</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">,[</span><span class="mi">1</span><span class="p">:</span><span class="n">k</span><span class="p">])</span>
    <span class="c"># take majority vote over all selected columns</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">float</span><span class="p">(</span><span class="n">A</span><span class="p">[:,</span><span class="n">a</span><span class="p">]</span> <span class="o">*</span> <span class="n">ones</span><span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="o">.&gt;</span> <span class="n">length</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">combine</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">)</span>
<span class="k">end</span></code></pre></div>

<p>I worked through the fun exercise of applying this algorithm in a separate <a href="http://nbviewer.ipython.org/gist/mrtzh/c41fd4c5897fc114a0d6">Julia notebook</a>. Here’s one picture that came out of it. Don’t treat the numbers as definitive as they all depend on the modeling assumptions I made.</p>

<div style="text-align:center">
<object data="/assets/heritage.svg" type="image/svg+xml">
  <img src="/assets/heritage.png" />
</object>
<p style="text-align:center">We see an improvement from 0.462311 (rank 146) to 0.451868  (rank 6).</p>
</div>

<p>The bottom line is: It seems to work reasonably well (under various semi-principled modeling assumptions I made). From the looks of it this might have given you an improvement <em>from rank 150ish to 6ish</em> within 700 submissions. Note there was a single team with 671 submissions. There’s a pretty good gap between number one on the <a href="http://www.heritagehealthprize.com/c/hhp/leaderboard/public">public leaderboard</a> and the rest. While possible in principle, it took me a bunch more submissions to get to the top. I should say though that I used the completely generic code from above without any optimizations specific to the competition. I didn’t even look at the data points (as I don’t have them). It’s possible that using the data and domain knowledge could improve things much further. I chose the Heritage Health prize, because it was the highest prized Kaggle competition ever (3 million dollars) and it ran for two years with a substantial number of submissions.</p>

<h2 id="how-robust-is-your-benchmark">How robust is your benchmark?</h2>

<p>There’s a broad lesson to be learned from this example. As computer scientists we love numerical benchmarks and rankings of all sorts. They look so objective and scientific that we easily forget how any benchmark is just a proxy for a more complex question. Every once in a while we should step back and ask: How robust is the benchmark? Do improvements in our benchmark really correspond to progress on the original problem? What I’d love to see in all empirical branches of computer science are adversarial robustness evaluations of various benchmarks. How far can we get by <em>gaming</em> rather than by actually making progress towards solving the problem?</p>

<p>Let me end on a positive note. What excites me is that the serious problems we saw in this post actually do have a fix (both in theory and in practice)! So, stay tuned for my next post.</p>

<p><em>Subscribe to the  <a href="http://blog.mrtz.org/feed.xml">RSS feed</a>
or follow me on <a href="https://www.twitter.com/mrtz">Twitter</a>.</em></p>

  </article>

</div>


    
<h2>Comments</h2>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'moodyrd'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    


      </div>
    </div>


    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Moody Rd</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>Moody Rd</li>
          <li><a href="mailto:blog@mrtz.org">blog@mrtz.org</a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/mrtzh">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">mrtzh</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/mrtz">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">mrtz</span>
            </a>
          </li>
          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">A blog about machine learning.</p>
      </div>
    </div>

  </div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-1818495-4', 'auto');
  ga('send', 'pageview');

</script>

</footer>


  </body>

</html>
