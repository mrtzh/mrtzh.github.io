<p>My blog post on the <a href="http://mrtz.org/blog/the-zen-of-gradient-descent/">Zen of Gradient Descent</a> hit the front page of <a href="https://news.ycombinator.com/item?id=8182991">Hacker News</a> the other day. I don't know how that happened. It got me more views in one day than this most humble blog usually gets in half a year. I thought I should take this as an excuse to extend the post a bit by elaborating on one remark I made only in passing. You don't need to go back to reading that post unless you want to. This one will be self contained.</p>
<p>The point I made is that basic Gradient Descent (GD) is noise tolerant in a way that Accelerated Gradient Descent (AGD) is not. That is to say, if we don't have exact but rather approximate gradient information, GD might very well outperform AGD even though its convergence rate is worse in the exact setting. The truth is I was sort of bluffing. I didn't actually have a proof of a formal statement that would nail down this point in a compelling way. It was more of a gut feeling based on some simple observations.</p>
<p>To break the suspense, I still haven't proved the statement I vaguely thought was true back then, but fortunately somebody else had already done that. This is a thought provoking <a href="http://www.optimization-online.org/DB_FILE/2010/12/2865.pdf">paper by Devolder, Glineur and Nesterov </a>(DGN). Thanks to Cristobal Guzman for pointing me to this paper. Roughly, what they show is that any method that converges faster than the basic gradient descent method must accumulate errors linearly with the number of iterations. Hence, in various noisy settings auch as are common in applications acceleration may not help---in fact, it can actually make things worse!</p>
<p>I'll make this statement more formal below, but let me first explain why I love this result. There is a tendency in algorithm design to optimize computational efficiency first, second and third and then maybe think about some other stuff as sort of an add-on constraint. We generally tend to equate faster with better. The reason why this is not a great methodology is that sometimes acceleration is mutually exclusive with other fundamental design goals. A theory that focuses primarily on speedups without discussing trade-offs with robustness misses a pretty important point.</p>
<h2>When acceleration is good</h2>
<p>Let's build some intuition for the result I mentioned before we go into formal details. Consider my favorite example of minimizing a smooth convex function $latex {f\colon \mathbb{R}^n\rightarrow\mathbb{R}}&amp;s=1$ defined as</p>
<p style="text-align: center;">$latex \displaystyle f(x) = \frac 12 x^T L x - b^T x &amp;s=1$</p>
<p>for some positive semidefinite $latex {n\times n}&amp;s=1$ matrix $latex {L}&amp;s=1$ and a vector $latex {b\in\mathbb{R}^n.}&amp;s=1$ Recall that the gradient is $latex {\nabla f(x)=Lx-b.}&amp;s=1$ An illustrative example is the <a href="http://en.wikipedia.org/wiki/Laplacian_matrix">Laplacian </a> of a <a href="http://en.wikipedia.org/wiki/Cycle_graph">cycle graph</a>:</p>
<p style="text-align: center;">$latex \displaystyle L = \left[ \begin{array}{ccccccc} 2 &amp; -1 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; -1 \\ -1 &amp; 2 &amp; -1 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ 0 &amp; -1 &amp; 2 &amp; -1&amp; 0 &amp; \cdots &amp; 0 \\ \vdots &amp; &amp; &amp; &amp; &amp; &amp; \end{array} \right] &amp;s=1$</p>
<p>Since $latex {L}&amp;s=1$ is positive semidefinite like any graph Laplacian, the function $latex {f}&amp;s=1$ is convex. The operator norm of $latex {L}&amp;s=1$ is bounded by~$latex {4}&amp;s=1$ and so we have that for all $latex {x,y\in\mathbb{R}^n:}&amp;s=1$</p>
<p style="text-align: center;">$latex \displaystyle \|\nabla f(x) -\nabla f(y)\| \le \|L\|\cdot\|x-y\|\le 4 \|x-y\|. &amp;s=1$</p>
<p>This means the function is also smooth and we can apply AGD/GD with a suitable step size. Comparing AGD and GD on this instance with $latex {n=100}&amp;s=1$, we get the following picture:</p>
<p><a href="http://mrtz.org/blog/wp-content/uploads/2014/08/no-noise.png"><img class="aligncenter size-large wp-image-376" src="http://mrtz.org/blog/wp-content/uploads/2014/08/no-noise-1024x640.png" alt="no-noise" width="850" height="531" /></a></p>
<p>It looks like AGD is the clear winner. GD is pretty slow and takes a few thousand iterations to decrease the error by an order of magnitude.</p>
<h2>When acceleration is bad</h2>
<p>The situation changes dramatically in the presence of noise. Let's repeat the exact same experiment but now instead of observing $latex {\nabla f(x)}&amp;s=1$ for any given $latex {x,}&amp;s=1$ we can only see $latex {\nabla f(x) + \xi}&amp;s=1$ where $latex {\xi}&amp;s=1$ is sampled from the $latex {n}&amp;s=1$-dimensional normal distribution $latex {N(0,\sigma^2)^n.}&amp;s=1$ Choosing $latex {\sigma=0.1}&amp;s=1$ we get the following picture:</p>
<p><a href="http://mrtz.org/blog/wp-content/uploads/2014/08/with-noise.png"><img class="aligncenter size-large wp-image-377" src="http://mrtz.org/blog/wp-content/uploads/2014/08/with-noise-1024x640.png" alt="with-noise" width="850" height="531" /></a></p>
<p>Gradient descent pretty quickly converges to essentially the best result that we can hope for given the noisy gradients. In contrast, AGD goes totally nuts. It doesn't converge at all and it adds up errors in sort of linear fashion. In this world, GD is the clear winner.</p>
<h2>A precise trade-off</h2>
<p>The first thing DGN do in their paper is to define a general notion of inexact first order oracle. Let's recall what an exact first-order oracle does for an (unconstrained) convex function $latex {f\colon\mathbb{R}^n\rightarrow \mathbb{R}}&amp;s=1$ with smoothness parameter $latex {L.}&amp;s=1$ Given any point $latex {x\in\mathbb{R}^n}&amp;s=1$ an exact first order oracle returns a pair $latex {(f_L(x),g_L(x))\in\mathbb{R}\times\mathbb{R}^n}&amp;s=1$ so that for all $latex {y\in\mathbb{R}^n}&amp;s=1$ we have</p>
<p style="text-align: center;">$latex \displaystyle 0\le f(y) - \big(f_L(x) + \langle g_L(x),y-x\rangle\big)\le \frac L2\|y-x\|^2\,. &amp;s=1$</p>
<p>Pictorially, at every point $latex {x}&amp;s=1$ the function can be sandwiched between a tangent linear function specified by $latex {(f_L(x),g_L(x))}&amp;s=1$ and a parabola. The pair $latex {(f(x),\nabla f(x))}&amp;s=1$ satisfies this constraint as the first inequality follows from convexity and the second from the smoothness condition. In fact, this pair is the only pair that satisfies these conditions. My slightly cumbersome way of desribing a first-order oracle was only so that we may now easily generalize it to an inexact first-order oracle. Specifically, an inexact oracle returns for any given point $latex {x\in\mathbb{R}^n}&amp;s=1$ a pair $latex {(f_{\delta,L}(x),g_{\delta,L}(x))\in\mathbb{R}\times\mathbb{R}^n}&amp;s=1$ so that for all $latex {y\in\mathbb{R}^n}&amp;s=1$ we have</p>
<p style="text-align: center;">$latex \displaystyle 0\le f(y) - \big(f_{\delta,L}(x) + \langle g_{\delta,L}(x),y-x\rangle\big)\le \frac L2\|y-x\|^2+\delta\,. &amp;s=1$</p>
<p>It's the same picture as before except now there's some $latex {\delta}&amp;s=1$ slack between the linear approximation and the parabola.<br />
With this notion at hand, what DGN show is that given access to $latex {\delta}&amp;s=1$-inexact first-order oracle Gradient Descent spits out a point $latex {x^t}&amp;s=1$ after $latex {t}&amp;s=1$ steps so that</p>
<p style="text-align: center;">$latex \displaystyle f(x^t) - \min_x f(x) \le O\big(L/t\big) + \delta\,. &amp;s=1$</p>
<p>The big-oh notation is hiding the squared distance between the optimum and the starting point. Accelerated Gradient Descent on the other hand gives you</p>
<p style="text-align: center;">$latex \displaystyle f(x^t) - \min_x f(x) \le O\big(L/t^2\big) + O\big(t \delta\big)\,. &amp;s=1$</p>
<p>Moreover, you cannot improve this-tradeoff between acceleration and error accumulation. That is any method that converges as $latex {1/t^2}&amp;s=1$ must accumulate errors as $latex {t\delta.}&amp;s=1$</p>
<h2>Open questions</h2>
<ol>
<li>The lower bound I just mentioned in the previous paragraph stems from the fact that an inexact first-order oracle can embed non-smooth optimization problems for which a speedup is not possible. This is interesting, but it doesn't resolve, for example, the question of whether there could be a speedup in the simple gaussian noise addition model that I mentioned above. This isn't even a toy model---as you might object---since gaussian noise addition is what you would do to make gradient descent privacy preserving. See for example an upcoming FOCS <a href="http://arxiv.org/pdf/1405.7085.pdf">paper by Bassily, Smith, Thakurta</a> for an analysis of gradient descent with gaussian noise.</li>
<li>Is there an analog of the DGN result in the eigenvalue world? More formally, can we show that any Krylov subspace method that converges asymptotically faster than the <a href="http://mrtz.org/blog/power-method/">power method</a> must accumulate errors?</li>
<li>The cycle example above is often used to show that any blackbox gradient method requires at least $latex {t\ge \Omega(1/\sqrt{\epsilon})}&amp;s=1$ steps to converge to error $latex {\epsilon}&amp;s=1$ provided that $latex {t}&amp;s=1$ is less than the number of vertices of the cycle, that is the dimension $latex {n}&amp;s=1$ of the domain. (See, for example, Theorem 3.9. in Sebastien Bubeck's <a href="http://arxiv.org/pdf/1405.4980v1.pdf">book</a>.) Are there any lower bounds that hold for $latex {t\gg n}&amp;s=1$?</li>
</ol>
<h2>Pointers:</h2>
<p>The code for these examples is available <a href="http://nbviewer.ipython.org/gist/mrtzh/4dc77fb84c3ba8b8b220">here</a>.</p>
<p style="text-align: center;"><em>To stay on top of future posts, subscribe to the <a style="color: #bc360a;" href="http://mrtz.org/blog/feed/">RSS feed</a> or follow me on <a style="color: #bc360a;" href="http://twitter.com/mrtz">Twitter</a>.</em></p>
